<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>tesigners</title>
    <description></description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 09 Jul 2020 21:34:55 +0900</pubDate>
    <lastBuildDate>Thu, 09 Jul 2020 21:34:55 +0900</lastBuildDate>
    <generator>Jekyll v3.7.2</generator>
    
      <item>
        <title>multiply algorithm</title>
        <description>&lt;p&gt;&lt;em&gt;알고리즘 산책, From Mathematics to Generic Programming&lt;/em&gt; 책의 내용을 &lt;a href=&quot;/aps/2020/05/25/aps-process.html&quot;&gt;알고리즘 문제해결 process&lt;/a&gt;에 맞추어 재해석해 정리해본다.&lt;/p&gt;

&lt;hr /&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;analysis&lt;/p&gt;

    &lt;p&gt;두 자연수의 곱셈을 계산하는 알고리즘.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;modeling&lt;/p&gt;

    &lt;p&gt;이 문제는 analytic solution이 존재하는 문제이다.&lt;/p&gt;

    &lt;p&gt;곱셈은 “뭔가를 몇 번 더하는 것”으로 정의한다.&lt;/p&gt;

    &lt;p&gt;더 형식을 갖추자면 곱셈은 1로 곱하는 것과 1보다 큰 수로 곱하는 것의 두 가지로 나눌 수 있다.&lt;/p&gt;

    &lt;p&gt;1로 곱하는 것은 다음과 같이 정의한다.&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;1a = a&lt;/script&gt;

    &lt;p&gt;이제 이미 계산한 것에 1을 더한 것을 곱하는 경우를 생각해 보자.&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;(n + 1)a = na + a&lt;/script&gt;

    &lt;p&gt;따라서, n과 a를 곱할 때는 a를 n번 더하면 된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;program&lt;/p&gt;

    &lt;p&gt;Recursive call을 이용한 c++ code는 다음과 같다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; int multiply0(int n, int a) {
     if (n == 1) return a;
     return multiply(n - 1, a) + a;
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;analysis&lt;/p&gt;

    &lt;p&gt;a를 n번 더하게 되므로, $O(N)$ 의 성능을 가진다.&lt;/p&gt;

    &lt;p&gt;덧셈 횟수를 더 낮출 수 있는 알고리즘을 생각해 본다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;modeling&lt;/p&gt;

    &lt;p&gt;러시아 소작농 알고리즘으로 알려진 방법을 참고한다. 이 알고리즘은, 덧셈의 결합법칙에 기반해, 다음과 같은 사실로 출발한다.&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;4a = ((a + a) + a) + a&lt;/script&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;= (a + a) + (a + a)&lt;/script&gt;

    &lt;p&gt;이 방법을 사용하면 $(a + a)$ 를 한 번만 계산하면 되기 때문에 덧셈 횟수를 줄일 수 있다.&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;이 알고리즘의 핵심은 n을 반으로 줄이고, a를 두 배로 키워서 2를 거듭제곱한 횟수만큼 더한 값을 만드는 것이다.&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;예를 들어,&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;41 \times 59 = (1 \times 59) + (8 \times 59) + (32 \times 59)&lt;/script&gt;

    &lt;p&gt;로 표현할 수 있는데, 우변의 곱해지는 수(1, 8, 32)는 41을 이진수로 썼을 때 1표 표시되는 비트에 해당하는 자리의 거듭제곱 수이다. 해당 수(1, 8, 41) 만큼 59를 더하는 것이다.&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;즉, 곱셈이 꼭 필요한 수 만큼의 덧셈으로 표현되며, 덧셈 또한 같은 수의 덧셈이고 이전 계산의 값을 사용하므로 연산 횟수와 복잡도가 현저하게 줄어든다.&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;단, 2의 제곱인 수를 더하고 있으므로, 홀수는 추가로 처리해줘야 한다.&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;odd(n) \Longrightarrow half(n) = half(n - 1)&lt;/script&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;program&lt;/p&gt;

    &lt;p&gt;c++ code로 구현하면 다음과 같다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; bool odd(int n) { return n &amp;amp; 0x1; }
 int half(int n) { return n &amp;gt;&amp;gt; 1; }
   
 int multiply(int n, int a) {
     if (n == 1) return a;
     int result = multiply(half(n), a + a);
       
     if (odd(n)) result = result + a;
       
     return result;
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;analysis&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;이 전 단계에의 최적화 결과를 확인해보고, 최적화 포인트가 더 있는지 분석해야 한다. 더이상 최적화가 필요없다고 판단되면, 문제 해결을 마무리 한다.&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;이전 단계 설계/구현의 목표는 덧셈 횟수를 줄이는 최적화였으므로, 설계/구현된 알고리즘의 덧셈 횟수 분석을 해봐야 한다.&lt;/p&gt;

    &lt;p&gt;분석 과정과 결과는 다음과 같다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;함수를 호출할 때마다 $a + a$ 에 들어있는 $+$ 에 해당하는 덧셈을 해야한다.&lt;/li&gt;
      &lt;li&gt;매번 재귀 호출을 할 때마다 값이 절반으로 줄어들기 때문에 이 함수는 총 $\log n$ 번 만큼 호출하게 된다.&lt;/li&gt;
      &lt;li&gt;result + a에 해당하는 덧셈도 가끔 계산해야 한다.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;따라서 총 덧셈 횟수는 다음의 식으로 구할 수 있다.&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;\#+(n) = \lfloor {\log n} \rfloor + (\nu(n) - 1)&lt;/script&gt;

    &lt;p&gt;$\nu(n)$ : $n$ 을 이진법으로 썼을 때 1의 개수&lt;/p&gt;

    &lt;p&gt;하지만, &lt;strong&gt;앞에서 구한 multiply1 함수는 재귀 호출을 $\log(n)$ 번 해야하는 문제가 있다.&lt;/strong&gt; 함수 호출 자체가 비용이 많이 발생하는 작업이므로 이 문제를 해결할 필요가 았다.&lt;/p&gt;

    &lt;p&gt;note) 위의 분석은 이 전 문제의 목표가 덧셈 횟수를 목표로 했기때문에, 덧셈 횟수에 대한 복잡도 분석만 진행됐다.&lt;/p&gt;

    &lt;p&gt;note) 함수 호출 비용에 대한 문제인식은 도메인 지식이 있기때문에 가능한 것이다. 주어진 문제의 도메인 지식도 같이 쌓아야 한다는 결론을 얻을 수 있다. 아는 만큼 보이는 것이다.&lt;/p&gt;

    &lt;p&gt;note) 이 알고리즘이 최적일까? 항상 그런건 아니다. 예를들어 15로 곱한다고 할 때 위 공식대로 계산해 보면, 다음과 같이 된다.&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;+(15) = 3 + 4 - 1 = 6&lt;/script&gt;

    &lt;p&gt;하지만 15로 곱할 때는 아래와 같이 하면 덧셈을 다섯 번만 하면 된다. (aka. addition chain)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; int multiply_by_15(int a) {
     int b = (a + a) + a;
     int c = b + b;
     return (c + c) + b;
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;modeling&lt;/p&gt;

    &lt;p&gt;recursive call을 loop으로 변경해서 함수호출 횟수를 줄여본다.&lt;/p&gt;

    &lt;p&gt;“적게 일하는 것보다 많이 일하는 게 더 쉬울 수도 있다” 원칙을 적용해 loop형태로 변경한다.&lt;/p&gt;

    &lt;p&gt;여기서는, recursive call function을 어떻게 loop function으로 바꾸는지 살펴볼 수 있다.&lt;/p&gt;

    &lt;p&gt;recursive call을 loop으로 바꾸려면, recursive function에 이 전 depth까지의 연산결과를 전달해줘야 한다. 
 이는 loop를 생각해보면 당연한 구조이다. 각 loop은 이전 loop의 결과위에서 실행되는 것이다.&lt;/p&gt;

    &lt;p&gt;결과적으로, 다음 단계의 결과를 리턴받아서 현재 단계의 계산을 수행하는 것에서 현재까지의 결과를 다음단계에서 계산하게 하는 것이다.&lt;/p&gt;

    &lt;p&gt;note) 이렇게 하면, 함수의 리턴결과가 구하고자 하는 답이 되므로 자연스럽게 tail-recursive가 된다.&lt;/p&gt;

    &lt;p&gt;곱셈 알고리즘에서는 곱셈누적을 이용해 현재까지의 연산결과를 다음 recursive call에 전달할 수 있다.&lt;/p&gt;

    &lt;p&gt;곱셈 누적의 연산은 다음과 같다.&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;r + na&lt;/script&gt;

    &lt;p&gt;$r$ 은 $na$ 의 일부를 계속 더한 값이다.&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;즉, 그냥 곱하기만 하는 게 아니라, 곱한 값을 더하는 곱셈 누적(multiply-accumulate)연산을 한다.&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;특정 결과만 보이는 것보다 일반적인 결과를 통째로 증명하는게 더 쉬운 경우에 적용할 수 있다.&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;루프 불변식은 다음과 같다.&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;r + na = (r_0 + n_0 \times a_0) + n \times a&lt;/script&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;program&lt;/p&gt;

    &lt;p&gt;multiply-and-accumulation을 적용한 recursive call구현은 다음과 같다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; int mul_acc0(int r, int n, int a) {
     if (n == 1) return r + a;
        
     if (odd(n))
         return mul_acc0(r + a, half(n), a + a);
     else 
         return mul_acc0(r, half(n), a + a);
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;odd()인 경우 $r = r + a$만 해주면 recursive call case를 한 번으로 줄일 수 있다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; int mul_acc1(int r, int n, int a) {
     if (n == 1) return r + a;
        
     if (odd(n)) r = r + a;
        
     return mul_acc1(r, half(n), a + a);
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;if (n == 1)도 odd(n)에 포함되므로, 아래와 같이 함수를 단순하게 만들 수 있다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; int mul_acc2(int r, int n, int a) {
     if (odd(n)) {
         r = r + a;
            
         if (n == 1) return r;
     }
        
     return mul_acc1(r, half(n), a + a);
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;위의 recursive function은 recursive call이 함수의 가장 마지막에만 있는 &lt;strong&gt;tail-recursive&lt;/strong&gt; function이다.&lt;/p&gt;

    &lt;p&gt;loop로 변경하기 위해서 &lt;strong&gt;tail-recursive&lt;/strong&gt;를 &lt;strong&gt;strict tail-recursive&lt;/strong&gt; function으로 만들어 준다.&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;strict tail-recursive&lt;/strong&gt; call은&lt;/p&gt;
    &lt;blockquote&gt;
      &lt;p&gt;모든 형식 매개변수를 각각에 상응하는 인자로 사용하는 tail-recursive call을 strict tail-recursive call이라고 한다.&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;아래와 같이 strict tail-recursive로 변경할 수 있다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; int mul_acc3(int r, int n, int a) {
     if (odd(n)) {
         r = r + a;
         if (n == 1) return r;
     }
        
     n = half(n);
     a = a + a;
     return mul_acc3(r, n, a)
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;마지막으로, 아래와 같이 tail-recursive 호출을 반복문 형태로 바꾼다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; int mul_acc4(int r, int n, int a) {
     while (true) {
         if (odd(n)) {
             r = r + a;
             if (n == 1) return r;
         }
            
         n = half(n);
         a = a + a;
    }
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;최적화된 함수는 multiply-and-accumulate 형태이기때문에 두 숫자만 받는 보조 함수를 만들어줘야 한다.&lt;/p&gt;

    &lt;p&gt;이 때, 곱하는 수 a를 대입만 함으로써 덧셈횟수를 한 번 더 줄일 수 있다. 보조함수는 아래와 같다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; int multiply3(int n, int a) {
     if (n == 1) return a;
        
     return mul_acc4(a, n - 1, a);
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;analysis&lt;/p&gt;

    &lt;p&gt;지금까지는 덧셈의 횟수 그리고 함수호출 횟수에 대해 제기된 문제를 해결했다. 이번에는 입력에 따라 성능이 영향을 받는 경우가 없는지 확인해 본다.&lt;/p&gt;

    &lt;p&gt;앞의 해법의 경우, n이 power of 2인경우, 이진수의 모든 자리 숫자가 1이 되어, 매번 $r = r + a$ 를 계산하게 되는 worst case가 된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;modeling&lt;/p&gt;

    &lt;p&gt;n 이 짝수이면 n 이 홀수가 될 때까지 n을 절반으로 나누고 a는 두 배로 키우는 작업을 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;program&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; int multiply3(int n, int a) {
     while (!odd(n)) {
         a = a + a;
         n = half(n);
     }
        
     if (n == 1) return a;
        
     return mul_acc4(a, n - 1, a);
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;이 경우, mul_acc4를 처음 호출할 때는 n이 항상 짝수이므로, 홀수인지 확인할 필요도 없다. 따라서 n - 1은 반으로 나누고 a는 두 배로해서 호출할 수 있다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; int multiply4(int n, int a) {
    while (!odd(n)) {
        a = a + a;
        n = half(n);
    }
       
    if (n == 1) return a;
       
    return mul_acc(a, half(n - 1), a + a);
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;key-words&quot;&gt;Key words&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;recursive&lt;/li&gt;
  &lt;li&gt;tail-recursive&lt;/li&gt;
  &lt;li&gt;strict tail-recursive&lt;/li&gt;
  &lt;li&gt;recursive to loop&lt;/li&gt;
  &lt;li&gt;문제 발굴 영역
    &lt;ol&gt;
      &lt;li&gt;time complexity
        &lt;ol&gt;
          &lt;li&gt;연산(덧셈) 횟수&lt;/li&gt;
          &lt;li&gt;function call 횟수&lt;/li&gt;
          &lt;li&gt;데이터 패턴에 따른 연산 횟수&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Thu, 09 Jul 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/aps/2020/07/09/mathalgo-multiply.html</link>
        <guid isPermaLink="true">http://localhost:4000/aps/2020/07/09/mathalgo-multiply.html</guid>
        
        
        <category>aps</category>
        
      </item>
    
      <item>
        <title>StepwiseRefine(4) - N Queens by recursion</title>
        <description>&lt;p&gt;&lt;em&gt;Niklaus Wirth, Program Development by Stepwise Refinement&lt;/em&gt;의 예제인 8-Queens 문제를 &lt;a href=&quot;/aps/2020/05/25/aps-process.html&quot;&gt;알고리즘 문제해결 process&lt;/a&gt;에서 정리한 방법을 따라 풀어가는 과정을 정리한다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/aps/2020/06/03/stepwiserefine-nqueens-loop.html&quot;&gt;loop을 통한 구현&lt;/a&gt;에 이어서, recusion procedure을 이용해 구현해 본다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Implementation 1
    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;analysis&lt;/p&gt;

        &lt;p&gt;여기서 제안된 방법은 비어있는 보드(?) 혹은 보드가 없는 상태에서, 보드를 한 단계씩 확장하면서 문제를 해결해 나갈 수 있다는 관점에서 시작한다.
 (해답의 유형에 따라 이 방법이 유효한다.)&lt;/p&gt;

        &lt;p&gt;각 단계는 queen이 안전하게 위치할 수 있는 한 개의 solution을 확보하는 것이고, 8개 column으로 확장할때 까지 이어진다.&lt;/p&gt;

        &lt;p&gt;이 확장 process는 Dijkstra에 의해 공식화(formulated)되어 있으며, recusion을 이용해 표현할 수 있다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;model/design solution&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; trycolumn(j) {
     i = 0
            
     while !safe and i==8
         test_square()
                
         if (safe)
             set_queen()
             x[j] = i
                    
             if (j &amp;lt; 8) trycolumn(j)
             if (!safe) remove_queen()
 }
        
 main() {
     trycolumn(1)
     if safe
         print(x)
     else
         print('fail')
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;program solution&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; #include &amp;lt;iostream&amp;gt;
 using namespace std;
        
 int pointer[9] = {0, };
        
 int a[9] = {0, };
 int b[30] = {0, };
 int c[30] = {0, };
        
 int test_square(int step, int row)
 {
     int square = row;
            
     int safe = a[square] | b[step + square] | c[step - square + 8];
            
     return !safe;
 }
        
 void set_queen(int step, int row)
 {
     int square = row;
            
     a[square] = b[step + square] = c[step - square + 8] = true;
 }
        
 void remove_queen(int step)
 {
     int square = pointer[step];
            
     a[square] = b[step + square] = c[step - square + 8] = false;
 }
        
 bool last_square(int step)
 {
     return pointer[step] == 8;
 }
        
 int tryColumn(int step)
 {
     int safe = 0;
            
     if (step &amp;gt; 8) return true;
            
     for (int i = 1; i &amp;lt;=8; ++i) {
         safe = test_square(step, i);
                
         if (safe) {
             set_queen(step, i);
             pointer[step] = i;
                        
             safe = tryColumn(step + 1);
                        
             if (!safe) remove_queen(step);
             else break;
         }
     }
            
     return safe;
 }
        
 int main(void)
 {
     int safe = 0;
        
     safe = tryColumn(1);
            
     if (safe) {
         cout &amp;lt;&amp;lt; endl;
         for (int i = 1; i &amp;lt; 9; ++i) {
             cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &quot;: &quot; &amp;lt;&amp;lt; pointer[i] &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; endl;
         }
     }
     else cout &amp;lt;&amp;lt; &quot;Failed&quot; &amp;lt;&amp;lt; endl;
            
     return 0;
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Implementation 2
    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;analysis&lt;/p&gt;

        &lt;p&gt;지금까지의 solution은 조건을 만족하는 첫 번째 한개의 답만 찾았다.&lt;/p&gt;

        &lt;p&gt;조건을 만족하는 모든 조합을 찾는 general solution을 도출해 본다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;model/design solution&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;program solution&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; #include &amp;lt;iostream&amp;gt;
 using namespace std;
        
 int pointer[9] = {0, };
        
 int a[9] = {0, };
 int b[30] = {0, };
 int c[30] = {0, };
        
 int solCount = 0;
        
 int test_square(int step, int row)
 {
     int square = row;
        
     int safe = a[square] | b[step + square] | c[step - square + 8];
        
     return !safe;
 }
        
 void set_queen(int step, int row)
 {
     int square = row;
        
     a[square] = b[step + square] = c[step - square + 8] = true;
 }
        
 void remove_queen(int step)
 {
     int square = pointer[step];
        
     a[square] = b[step + square] = c[step - square + 8] = false;
 }
        
 bool last_square(int step)
 {
     return pointer[step] == 8;
 }
        
 int tryColumn(int step)
 {
     int safe = 0;
        
     if (step &amp;gt; 8) {
         solCount += 1;
         for (int i = 1; i &amp;lt; 9; ++i) {
             cout &amp;lt;&amp;lt; pointer[i] &amp;lt;&amp;lt; &quot; &quot;;
         }
         cout &amp;lt;&amp;lt; endl;
        
         return true;
     }
        
     for (int i = 1; i &amp;lt;=8; ++i) {
         safe = test_square(step, i);
        
         if (safe) {
             set_queen(step, i);
             pointer[step] = i;
        
             safe = tryColumn(step + 1);
        
             remove_queen(step);
         }
     }
        
     return safe;
 }
        
 int main(void)
 {
     int safe = 0;
        
     safe = tryColumn(1);
        
     cout &amp;lt;&amp;lt; &quot;Sol Count: &quot; &amp;lt;&amp;lt; solCount &amp;lt;&amp;lt; endl;
     return 0;
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Wed, 03 Jun 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/aps/2020/06/03/stepwiserefine-nqueens-recursion.html</link>
        <guid isPermaLink="true">http://localhost:4000/aps/2020/06/03/stepwiserefine-nqueens-recursion.html</guid>
        
        
        <category>aps</category>
        
      </item>
    
      <item>
        <title>StepwiseRefine(3) - N Queens by loop</title>
        <description>&lt;p&gt;&lt;em&gt;Niklaus Wirth, Program Development by Stepwise Refinement&lt;/em&gt;의 예제인 8-Queens 문제를 &lt;a href=&quot;/aps/2020/05/25/aps-process.html&quot;&gt;알고리즘 문제해결 process&lt;/a&gt;에서 정리한 방법을 따라 풀어가는 과정을 정리한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Problem&lt;/p&gt;

    &lt;p&gt;Given are an 8x8 chessboard and 8 queens which are hostile to each other.&lt;/p&gt;

    &lt;p&gt;Find a position for each queen (a configuration) such that no queen may be taken by any other queen.&lt;/p&gt;

    &lt;p&gt;(i.e. such that every row, column and diagonal contains at most one queen)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Problem analysis phase&lt;/strong&gt;&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;analysis problem&lt;/p&gt;

        &lt;p&gt;condition $p$ : every row, column and diagonal contains at most one queen&lt;/p&gt;

        &lt;p&gt;8x8 chess판에서 condition $p$ 를 만족하는 8개의 위치를 찾는 것이 문제이다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;model/design solution&lt;/p&gt;

        &lt;p&gt;solution $x$ 는 다음과 같이 표현할 수 있다.&lt;/p&gt;

        &lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;x = 8 \ locs \in \{A \cap p(x)\}&lt;/script&gt;
 &lt;script type=&quot;math/tex&quot;&gt;where\ loc = (row, col)&lt;/script&gt;&lt;/p&gt;

        &lt;script type=&quot;math/tex; mode=display&quot;&gt;where\ A=all\ position\ of\ chess, 8 \times 8&lt;/script&gt;

        &lt;p&gt;analytic solution이 존재하지 않는 문제로, trial error방법으로 답을 찾아가야 한다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;program solution&lt;/p&gt;

        &lt;p&gt;trial and error 전략으로 문제를 해결하는  pseudo code는 다음과 같다. 문제 공간은 모든 경우의 수가 되고, 이를 검색하고 조건을 확인해 답을 구하게 된다.&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; do
     x = generate_next_cand(A)
 while p(x) or (no more elements in A) 
     
 if p(x)
       solution = x; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Architecture decision phase-1&lt;/strong&gt;&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;analysis&lt;/p&gt;

        &lt;p&gt;초기 구현의 complexity를 분석해보면&lt;/p&gt;

        &lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;complexity = _{64}\mathrm{C}_{8} = \frac{64!}{56! \times 8!} \approx 2^{32}&lt;/script&gt;
 로 제한 시간 1sec을 만족하지 못 한다.&lt;/p&gt;

        &lt;p&gt;note) 제한시간 1sec은 대략 complexity $10^9$ 정도 이다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;model/design solution&lt;/p&gt;

        &lt;p&gt;초기 구현은 모든 경우의 수를 탐색하는 방법으로 불필요한 경우의 수까지 탐색하고 있다.&lt;/p&gt;

        &lt;p&gt;이 경우, 불필요한 문제영역을 제거함으로써, 그 공간을 줄이는 방법을 적용해 성능을 제고할 수 있다.&lt;/p&gt;

        &lt;p&gt;문제 공간을 줄이는 방법으로 &lt;strong&gt;strategy of preselection&lt;/strong&gt;을 적용해볼 수 있다.&lt;/p&gt;

        &lt;p&gt;$p = q \cap r$ 인 $q$ 와 $r$ 을 다음과 같이 정의할 수 있다.&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;$r$ : in every column, there must be one queen&lt;/li&gt;
          &lt;li&gt;&amp;lt;a name=“condition-q”&amp;gt; $q$ : in every row and diagonal, there must be one queen&lt;/li&gt;
        &lt;/ul&gt;

        &lt;p&gt;이 때, preselected set은 다음과 같이 정의된다.&lt;/p&gt;

        &lt;script type=&quot;math/tex; mode=display&quot;&gt;B_r = \{x | (x \in A) \wedge r(x)\}&lt;/script&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;a name=&quot;aph1-program-solution&quot;&gt;program solution&lt;/a&gt;&lt;/p&gt;

        &lt;p&gt;문제 공간만 줄어들 뿐, trial and error와 동일하다.&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;do 
    x = generate_next_candidate(Br)
while q(x) || empty(Br)

if q(r)
    solution = x
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Architecture decision phase 2&lt;/strong&gt;&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;analysis&lt;/p&gt;

        &lt;p&gt;&lt;a href=&quot;#aph1-program-solution&quot;&gt;두 번째 solution&lt;/a&gt;의 complexity분석은 다음과 같다.&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;$B_r$ 의 크기(complexity)는 condition $r$ 의 정의에 따라, 8개 각 column별 8개의 row가 가능한 조합이므로&lt;/p&gt;

            &lt;script type=&quot;math/tex; mode=display&quot;&gt;8^8 = (2 ^ 3)^8 = 2^{24}&lt;/script&gt;
          &lt;/li&gt;
        &lt;/ul&gt;

        &lt;p&gt;이 된다.&lt;/p&gt;

        &lt;p&gt;하지만, 명백히 성립되지 않는 조합에 대해서도 $q(x)$ check를 수행하고 있다. 예를 들어 $x = x[0], x[1], x[2], …, x[7]$ 이라고 했을 때, $x[1]$ 이 $q(x)$ 를 만족하지 못하면, $x[2], …, x[7]$ 는 명백하게 해답이 될 수 없음에도 탐색을 하게 된다.&lt;/p&gt;

        &lt;p&gt;이 점을 문제로 정의할 수 있다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;model/design solution&lt;/p&gt;

        &lt;p&gt;8 queens solution은&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;${x1, x2, …, x8}$ 의 형식으로 ${x1, …, xj}$ 의 &lt;em&gt;trial solution&lt;/em&gt;을 만들 수 있고&lt;/li&gt;
          &lt;li&gt;&lt;em&gt;trial solution&lt;/em&gt;이 실패하면, 해당 &lt;em&gt;trial solution&lt;/em&gt;의 extension도 fail하게 된다.&lt;/li&gt;
        &lt;/ul&gt;

        &lt;p&gt;즉, back tracking 적용이 가능한 solution type이다. &lt;a href=&quot;/aps/2020/05/26/solution-model.html&quot;&gt;참조&lt;/a&gt;&lt;/p&gt;

        &lt;p&gt;back tracking template code는 다음과 같다.&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; j = 1
 do 
     result = try_step(j)
     if result == successful
        advance(j + 1)
     else
        regress(j - 1)
 while (j &amp;lt; 1) || (j &amp;gt; n)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;program solution&lt;/p&gt;

        &lt;p&gt;back tracking code template을 도입한 첫번째 solution code는 다음과 같다.&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; board
 pointer
 safe

 consider_first_column()

 while not last_col_done and not regress_outof_firstcol
     safe = trycolumn()
            
     if safe
         set_queen()
         consider_next_column()
    else
         regress()

 if last_step_done()
     print(board)
 else
     print(&quot;failed&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Elaboration phase 0&lt;/strong&gt;
    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;analysis&lt;/p&gt;

        &lt;p&gt;backtracking의 핵심인 trystep()과  regress()를 상세화 한다.&lt;/p&gt;

        &lt;p&gt;이 때, stepwise construction이 가능해야 한다는 것을 염두에 두어야 한다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;model/design solution&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;program solution&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; trystep(step) {
     while not(safe) and not(last_square)
         safe = test_square(step, pointer)
         advance_pointer()
              
     return safe
 }
      
 regress(step, pointer) {
     reconsider_prior_step()
            
     if not(regress_outof_firststep)
         removequeen()
                        
     // 하나의 row에 하나의 퀸만 가능하므로, regress한 위치가 마지막 row이면, 
     // 다시 시도해도 safe가 없을것이 자명하므로 한 step더 뒤로 돌아간다.
     // 확인해봐야 함.
            
     if last_square()
         reconsider_prior_column()
         if not(regres_outof_firststep())
             removequeen()                        
 }
      
 main() {
     board: let 8x8 array
     pointer: let array of 1x8
     safe: variable
            
     consider_first_step()
     while not last_col_done and  not regress_outof_firststep
         if trystep() == safe
             set_queen()
             consider_next_step()
         else
             regress()
                
     if last_col_done
         print(x)
     else
         print('fail')
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Coding phase 0&lt;/strong&gt;
    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;analysis&lt;/p&gt;

        &lt;p&gt;elaboration의 수준이 code로 포현할 수 밖에 없게될 때 coding phase로 넘어간다.&lt;/p&gt;

        &lt;p&gt;이 단계에서는 다음과 같은 상세화를 진행한다.&lt;/p&gt;

        &lt;p&gt;data structure를 정의할 때 유의할 점은 &lt;a href=&quot;/aps/2020/05/26/solution-model.html&quot;&gt;여기&lt;/a&gt;를 참고한다.&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;data structure 정의&lt;/li&gt;
          &lt;li&gt;간단한 변수의 데이터 타입정의 및 관련 method 상세화&lt;/li&gt;
          &lt;li&gt;step과 pointer 정의&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;model/design solution&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;program solution&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; board
 int step (0 &amp;lt;= step &amp;lt;= 9)
 int pointer[1:8] 
        
 consider_first_column() {
     step = 1
     pointer[1] = 0
 }
        
 consider_next_step(step) {
     step = step + 1
     pointer[step] = 0
 }
        
 advance_pointer(step) {
     pointer[step] += 1
 }
        
 reconsider_prior_step(step) {
     step = step - 1
 }
        
 regress_outof_firststep(step) {
     return step &amp;lt; 1
 }
        
 last_step_done(step) {
     return step &amp;gt; 8
 }
          
 last_square(step) {
     return pointer[step] &amp;gt; 8
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Coding phase 1&lt;/strong&gt;
    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;analysis&lt;/p&gt;

        &lt;p&gt;상세화되지 않는 function중 &lt;em&gt;test_square()&lt;/em&gt;는 가장 자주 불리는 함수고, 가장 비싼 함수다. 따라서, 이 함수가 성능을 좌우하게 된다.&lt;/p&gt;

        &lt;p&gt;각 column의 8개의 row를 loop으로 검사할 수도 있지만, 조사할 조건의 특성, 주어진 문제의 특징을 이용해 자료구조를 정의하면 간단한 연산 한번으로 조사를 할 수 있다.&lt;/p&gt;

        &lt;p&gt;다음과 같이 주어진 조건 &lt;a href=&quot;#condition-q&quot;&gt;q(x)&lt;/a&gt;와 좌표 특성을 이용하여      자료구조를 정의한다.&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;같은 /-diagonal에 위치한 %loc(row, col)%는 %val = row + col%이 같은 값을 가진다.&lt;/li&gt;
          &lt;li&gt;같은 -diagoal에 위치한 %loc(row, col)%은 %val = row - col%이 같은 값을 가진다.&lt;/li&gt;
        &lt;/ul&gt;

        &lt;p&gt;자료구조는 다음과 같이 정의할 수 있다.&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;a[1:8] = true: no queen is positioned in row&lt;/li&gt;
          &lt;li&gt;b[2:16] = true: no queen is positioned in the /-diagonal&lt;/li&gt;
          &lt;li&gt;c[-7:7] = true: no queen is positioned in the -diagonal&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;model/design solution&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;program solution&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; test_square(step, pointer) {
     safe = a[pointer] or b[step + pointer] or c[step - pointer]
     return safe
 }
                
 set_queen(step, pointer) {
     a[pointer] = b[step + pointer] = c[step - pointer] = false
 }
    
 remove_queen(step) {
     a[pointer] = b[step + pointer] = c[step - pointer] = false
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Coding phase 2&lt;/strong&gt;
    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;analysis&lt;/p&gt;

        &lt;p&gt;상세화된 결과를 모두 합친 entire code 도출한다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;model/design Solution&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;program solution&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; int step (0 &amp;lt;= step &amp;lt;= 9)
 int pointer[1:8] 
 a[1:8] = true: no queen is positioned in row
 b[2:16] = true: no queen is positioned in the /-diagonal
 c[-7:7] = true: no queen is positioned in the \-diagonal
        
 consider_first_column() {
     step = 1
     pointer[1] = 0
 }
    
 consider_next_step(step) {
     step = step + 1
     pointer[step] = 0
 }
    
 advance_pointer(step) {
     pointer[step] += 1
 }
    
 reconsider_prior_step(step) {
     step = step - 1
 }
    
 regress_outof_firststep(step) {
     return step &amp;lt; 1
 }
    
 last_step_done(step) {
     return step &amp;gt; 8
 }
    
 last_square(step) {
     return pointer[step] &amp;gt; 8
 }
    
 test_square(step, pointer) {
     safe = a[pointer] or b[step + pointer] or c[step - pointer]
     return safe
 }
            
 set_queen(step, pointer) {
     a[pointer] = b[step + pointer] = c[step - pointer] = false
 }
            
 remove_queen(step) {
     a[pointer] = b[step + pointer] = c[step - pointer] = false
 }

 main() {
     board: let 8x8 array
     pointer: let array of 1x8
     safe: variable
            
     consider_first_step()
            
     while last_col_done or regress_outof_firststep {
         if trystep() == safe
             set_queen()
             consider_next_step()
         else
             regress()
     }
                
     if last_col_done
         print(x)
     else
         print('fail')
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Implementation 1&lt;/strong&gt;
    &lt;ol&gt;
      &lt;li&gt;analysis&lt;/li&gt;
      &lt;li&gt;model/design solution&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;program solution&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; #include &amp;lt;iostream&amp;gt;
 using namespace std;
        
 int step = 1;
 int row = 0;
        
 int pointer[9] = {0, };
        
 int a[9] = {0, };
 int b[30] = {0, };
 int c[30] = {0, };
        
 int test_square(int row)
 {
     int square = row;
            
     int safe = a[square] | b[step + square] | c[step - square + 8];
            
     return !safe;
 }
        
 void set_queen(int row)
 {
     int square = row;
            
     a[square] = b[step + square] = c[step - square + 8] = true;
 }
        
 void remove_queen(void)
 {
     int square = pointer[step];
            
     a[square] = b[step + square] = c[step - square + 8] = false;
 }
        
 bool last_square()
 {
     return pointer[step] &amp;gt; 8;
 }
        
 void regress(void)
 {
     step -= 1;
            
     if (step &amp;gt;= 1) {
         remove_queen();
                
         if (last_square()) {
             step -= 1;
                    
             if (step &amp;gt;= 1) remove_queen();
         }
     }
 }
        
 int main(void)
 {
     /*
      * try step
      */
     while ((step &amp;lt;= 8) &amp;amp;&amp;amp; (step &amp;gt;= 1)) {
         int safe = 0;
                
         while (!safe &amp;amp;&amp;amp; (row != 8)) {
             row += 1;
                    
             safe = test_square(row);
         }
                
         if (safe) {
             set_queen(row);
                    
             pointer[step] = row;
                    
             step += 1;
             row = 0;
         }
         else {
             regress();
             row = pointer[step];
         }
     }
            
     if (step &amp;gt; 8) {
         cout &amp;lt;&amp;lt; endl;
         for (int i = 1; i &amp;lt; 9; ++i) {
             cout &amp;lt;&amp;lt; pointer[i] &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; endl;
         }
     }
     else cout &amp;lt;&amp;lt; &quot;Failed&quot; &amp;lt;&amp;lt; endl;
            
     return 0;
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Implementation 2&lt;/strong&gt;
    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;analysis&lt;/p&gt;

        &lt;p&gt;global variable인 &lt;em&gt;step&lt;/em&gt;을 parameter전달로 local variable로 만든다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;model/design solution&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;program solution&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; #include &amp;lt;iostream&amp;gt;
 using namespace std;
        
 int pointer[9] = {0, };
        
 int a[9] = {0, };
 int b[30] = {0, };
 int c[30] = {0, };
        
 int test_square(int step, int row)
 {
     int square = row;
            
     int safe = a[square] | b[step + square] | c[step - square + 8];
            
     return !safe;
 }
        
 void set_queen(int step, int row)
 {
     int square = row;
            
     a[square] = b[step + square] = c[step - square + 8] = true;
 }
        
 void remove_queen(int step)
 {
     int square = pointer[step];
            
     a[square] = b[step + square] = c[step - square + 8] = false;
 }
        
 bool last_square(int step)
 {
     return pointer[step] &amp;gt; 8;
 }
        
 int regress(int step)
 {
     step -= 1;
            
     if (step &amp;gt;= 1) {
         remove_queen(step);
                
         if (last_square(step)) {
             step -= 1;
                    
             if (step &amp;gt;= 1) remove_queen(step);
         }
     }
            
     return step;
 }
        
 int main(void)
 {
     int row = 0;
     int step = 1;
            
     /*
      * try step
      */
     while ((step &amp;lt;= 8) &amp;amp;&amp;amp; (step &amp;gt;= 1)) {
         int safe = 0;
                
         while (!safe &amp;amp;&amp;amp; (row != 8)) {
             row += 1;
                    
             safe = test_square(step, row);
         }
                
         if (safe) {
             set_queen(step, row);
                    
             pointer[step] = row;
                    
             step += 1;
             row = 0;
         }
         else {
             step = regress(step);
             row = pointer[step];
         }
     }
            
     if (step &amp;gt; 8) {
         cout &amp;lt;&amp;lt; endl;
         for (int i = 1; i &amp;lt; 9; ++i) {
             cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &quot;: &quot; &amp;lt;&amp;lt; pointer[i] &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; endl;
         }
     }
     else cout &amp;lt;&amp;lt; &quot;Failed&quot; &amp;lt;&amp;lt; endl;
            
     return 0;
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Post mortem&lt;/strong&gt;
    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;analysis&lt;/p&gt;

        &lt;p&gt;지금까지의 solution은 조건을 만족하는 첫 번째 한개의 답만 찾았다.&lt;/p&gt;

        &lt;p&gt;조건을 만족하는 모든 조합을 찾는 general solution을 도출해 본다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;model/design solution&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;program solution&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; #include &amp;lt;iostream&amp;gt;
 using namespace std;
        
 int pointer[9] = {0, };
        
 int a[9] = {0, };
 int b[30] = {0, };
 int c[30] = {0, };
        
 int test_square(int step, int row)
 {
     int square = row;
            
     int safe = a[square] | b[step + square] | c[step - square + 8];
            
     return !safe;
 }
        
 void set_queen(int step, int row)
 {
     int square = row;
            
     a[square] = b[step + square] = c[step - square + 8] = true;
 }
        
 void remove_queen(int step)
 {
     int square = pointer[step];
            
     a[square] = b[step + square] = c[step - square + 8] = false;
 }
        
 bool last_square(int step)
 {
     return pointer[step] &amp;gt; 8;
 }
        
 int regress(int step)
 {
     step -= 1;
            
     if (step &amp;gt;= 1) {
         remove_queen(step);
                
         if (last_square(step)) {
             step -= 1;
                    
             if (step &amp;gt;= 1) remove_queen(step);
         }
     }
            
     return step;
 }
        
 int main(void)
 {
     int row = 0;
     int step = 1;
        
     int solCount = 0;
        
     /*
      * try step
      */
     while (step &amp;gt;= 1) {
         int safe = 0;
                
         while (!safe &amp;amp;&amp;amp; (row != 8)) {
             row += 1;
                    
             safe = test_square(step, row);
         }
                
         if (safe) {
             set_queen(step, row);
                    
             pointer[step] = row;
                    
             step += 1;
             row = 0;
        
             if (step &amp;gt; 8) {
                 solCount += 1;
        
                 for (int i = 1; i &amp;lt; 9; ++i) {
                     cout &amp;lt;&amp;lt; pointer[i] &amp;lt;&amp;lt; &quot; &quot;;
                 }
                 cout &amp;lt;&amp;lt; endl;
        
                 step = regress(step);
                 row = pointer[step];
             }
         }
         else {
             step = regress(step);
             row = pointer[step];
         }
     }
        
     cout &amp;lt;&amp;lt; &quot;Total solutions: &quot; &amp;lt;&amp;lt; solCount &amp;lt;&amp;lt; endl;
     return 0;
 }
        
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Wed, 03 Jun 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/aps/2020/06/03/stepwiserefine-nqueens-loop.html</link>
        <guid isPermaLink="true">http://localhost:4000/aps/2020/06/03/stepwiserefine-nqueens-loop.html</guid>
        
        
        <category>aps</category>
        
      </item>
    
      <item>
        <title>StepwiseRefine(2) - 프로그램 모델링 기법</title>
        <description>&lt;p&gt;&lt;em&gt;Niklaus Wirth, Program Development by Stepwise Refinement&lt;/em&gt; 에서 제시한 solution model 기법 몇가지를 정리한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;model for &lt;strong&gt;Trial and error solution type&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;해법 유형(solution type)이 아래와 같을 때에는&lt;/p&gt;

    &lt;p&gt;$solution= x \in A \cap p(x)$&lt;/p&gt;

    &lt;p&gt;다음의 프로그램 모델을 적용해 해법을 도출할 수 있다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  do
     x = generate_next_cand(A)
  while p(x) or (no more elements in A) 
     
  if p(x)
      solution = x; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;strategy of preselection&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;전체 문제 공간이 너무 큰 경우, 부분 조건을 선택해 선제적으로 문제 공간을 줄일 수 있다.&lt;/p&gt;

    &lt;p&gt;1번 항목의 전체 문제 공간 $p(x)$ 를 다음과 같이 표현할 수 있을 때&lt;/p&gt;

    &lt;p&gt;$p = q \cap r$&lt;/p&gt;

    &lt;p&gt;$r(x)$ 조건을 전체 문제공간에 선제적으로 적용함으로써 문제공간을 $q(x)$로 줄일 수 있다.&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;B_r = \{x | (x \in A) \wedge r(x)\}&lt;/script&gt;

    &lt;p&gt;이 때, 조건 $r$ 은 다음과 같아야 한다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;$B_r$ is much smaller than $A$&lt;/li&gt;
      &lt;li&gt;elements of $B_r$ are easily generated&lt;/li&gt;
      &lt;li&gt;condition $q$ is easier to test than $p$.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;이 때, 프로그램 모델을 다음과 같다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; do 
    x = generate_next_candidate(Br)
 while q(x) || empty(Br)

 if q(r)
    solution = x
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;model for &lt;strong&gt;back tracking&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;2번의 과정으로 문제공간을 줄였음에도 불구하고, 특정 유형의 해답의 경우, 명백하게 오답인 것을 알고도 해당 문제공간을 탐색하게 된다. 명백한 오류 공간을 탐색하지 않음으로써, 문제공간을 줄일 수가 있다.&lt;/p&gt;

    &lt;p&gt;이 문제를 해결하는 프로그램 모델이 back tracking이다.&lt;/p&gt;

    &lt;p&gt;위에서 말한 특정 유형이란, 해답(solution)이 stepwise construction이 가능한 경우를 말한다. 이를 판단하는 기준은 아래와 같다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; find representation of a trial solution
    
   trial solution = [x1], [x1, x2], .... [x1, x2, ... xj], ..., [x1, x2, ... xn]

   1. full solution can never be obtained by extending a partial trial solution which does not satisfy the predicate.
   2. partial solution satisfying predicate q may not extensible into a complete solution
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;위의 판단 기준에 따라 partial solution을 modeling하면, 다음과 같은 back tracking 프로그램 모델을 적용할 수 있다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; j = 1
 do 
   result = try_step(j)
   if result == successful
     advance(j + 1)
     else
     regress(j - 1)
 while (j &amp;lt; 1) || (j &amp;gt; n)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;note) 여기서 주의해야 할 점은 step j 을 지정해서 trial solution을 지정할 수 있어야 한다. step에 따라 동일한 trial solution을 만들 수 없으면, regression을 할 수가 없다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;data strcture 정의시 유의사항&lt;/p&gt;

    &lt;p&gt;아래는 해당 논문에서 data structure 결정시 유의할 점에 대한 부분을 발췌한 것이다.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;determine data which is key to the solution and how to express them for algorithm use&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;blockquote&gt;
      &lt;ul&gt;
        &lt;li&gt;the success of an algorithm depends almost always on suitable choice of its data representation &lt;strong&gt;in the light of the ease in which this representation allows the necessary operations to be expressed&lt;/strong&gt;.&lt;/li&gt;
        &lt;li&gt;consideration regarding storage requirements may be of prime importance&lt;/li&gt;
        &lt;li&gt;In general, it is advisable to delay decisions about data representation as long as possible&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;위에 정리한 solution type 이외의 유형도 분석해, 이에 적용할 수 있는 프로그램 모델을 추가 조사해야 한다.&lt;/p&gt;
</description>
        <pubDate>Tue, 26 May 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/aps/2020/05/26/solution-model.html</link>
        <guid isPermaLink="true">http://localhost:4000/aps/2020/05/26/solution-model.html</guid>
        
        
        <category>aps</category>
        
      </item>
    
      <item>
        <title>StepwiseRefine(1) - 알고리즘 문제해결 Process</title>
        <description>&lt;p&gt;&lt;em&gt;Niklaus Wirth, Program Development by Stepwise Refinement&lt;/em&gt; 를 참고해서, 알고리즘 문제 해결에 적용할 문제해결 Process를 정리해 본다.&lt;/p&gt;

&lt;p&gt;문제 해결 과정은 아래와 같이 3개 과정으로 정의할 수 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;문제 분셕 (Analysis problem)&lt;/p&gt;

    &lt;p&gt;문제 분석을 통해 해법을 특정한다.&lt;/p&gt;

    &lt;p&gt;문제는 처음 주어진 문제가 될 수 있고, 이전 단계에서 모델링 된 해법이 될 수 있다.&lt;/p&gt;

    &lt;p&gt;이전 단계에서 모델링 된 해법의 경우 공간/시간 복잡도 분석을 통해 최적화 대상이 될 수 있는 것이 발견되면, 그 지점을 문제로 정의할 수 있다. 딱히 대상이 발견되지 않으면 문제 해결과정을 마치면 된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;문제 모델링 및 해법 도출 (Model/Design solution)&lt;/p&gt;

    &lt;p&gt;특정된 해법을 모델링 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;해법 프로그램 (Program solution)&lt;/p&gt;

    &lt;p&gt;설계/해법을 수행할 수 있는 프로그램을 작성하고 검토/검증한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;위의 과정은 알고리즘 문제뿐 아니라, 모든 문제를 해결해 나가는 과정을 간단하게 추상화한 것이다. 이 과정을 문제해결 단계에 맞추어 적용하고 운용하는 것이 문제해결 능력 향상의 핵심이다.&lt;/p&gt;

&lt;p&gt;우리가 해결하고자 하는 대부분의 문제는 처음부터 구체적으 해결책을 도출하기 힘들다.
이런 추상적인 문제는 구체화하는 과정을 거치고, 구체화된 문제를 작은 문제로 나누면 어럽지않게 문제를 해결해 나갈 수 있다. 위 기본 문제 해결 과정을 문제의 구체화, 세분화 과정에 적용해서 큰 문제를 해결할 수 있다.&lt;/p&gt;

&lt;p&gt;요약하자면, 모든 문제는 analytic solution을 가지고 있거나 atomic 문제가 아닌 경우, 몇개의 작은 문제로 나눌 수 있고 device and conquer로 해결해 나갈 수 있다.&lt;/p&gt;

&lt;p&gt;구체화, 세분화 관점에서 문제 해결 단계를 아래의 4가지 단계로 정의할 수 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Problem analysis phase
 &lt;strong&gt;solution type을 분석해서 기본 해법 pseudo code를 만든다.&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;이 단계에서는 문제가 무엇인지 주어진 문장, 예시, 제약조건 등을 면밀히 분석해 해법을 특정한다.&lt;/p&gt;

    &lt;p&gt;문제에서 주어진 조건들과 구하고자 하는 답 사이의 관계를 분석하면 기본적인 접근방법을 설정할 수 있다.&lt;/p&gt;

    &lt;p&gt;예를 들어 문제에서 주어진 조건과 구하고자 하는 답 사이에 analytic solution이 존재한다면, 그 해법 알고리즘을 구현한다.
 반면, analytic solution이 존재하지 않는다면, 문제 공간에서 trial and error 정책으로 문제해결에 접근해야 한다.&lt;/p&gt;

    &lt;p&gt;따라서, 이 단계에서는 문제에서 주어진 조건과 답 사이의 관계에 초점을 두고 문제 분석을 진행해, 기본적인 접근방법을 정의하고 그 접근 방법을 pseudo code형태를 정의한다.&lt;/p&gt;

    &lt;p&gt;이 단계에서는 solution type과 그 psudo code 패턴을 알고 있어야 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Architecture decision phase&lt;/p&gt;

    &lt;p&gt;1번 과정에서 도출한 해법은 주어진 문제 해결에만 집중한 결과물로 대부분 시간에 대한 성능을 고려되지 않는다. 물론 경험이 쌓이면, 한 번의 시도로 성능까지 고려한 해법을 도출할 수도 있을 것이다.&lt;/p&gt;

    &lt;p&gt;이 과정에서는, 기본 해법코드의 성능을 문제로 정의한다. 성능은 O() notation을 이용한 complexity로 분석한다.&lt;/p&gt;

    &lt;p&gt;pseudo code의 temporal/spatial complexity를 분석하고 개선할 수 있는 design decision을 내린다. design decision을 반영해 pseudo code를 개선하고, 목표로하는 성능에 도달할때까지 이 과정을 반복한다.&lt;/p&gt;

    &lt;p&gt;이 단계에서는 주어진 문제에 대한 해답을, 주어진 시간/공간 제한내에 해결할 수 있는 기본 틀을 결정하는 것이다. 주어진 시간/공간이라는 &lt;strong&gt;문제&lt;/strong&gt;를 해결하는 단계인 것이다.&lt;/p&gt;

    &lt;p&gt;이 단계에서는 여러 패턴의 코드를 대상으로 complexity를 분석할 수 있는 능력과 그 개선책에 대한 많은 아이디어를 도출할 수 있는 능력이 요구된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Elaboration phase&lt;/p&gt;

    &lt;p&gt;이 단계에 이르면, 문제 해결의 틀(architecture)은 정해진다.&lt;/p&gt;

    &lt;p&gt;이 단계에서는 도출된 문제 해결 프로그램 중 상세화가 필요한 activity를 찾아 자세하게 기술하는 단계이다.&lt;/p&gt;

    &lt;p&gt;이 과정을 통해 세부 동작 및 attribute 등을 도출한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Coding phase&lt;/p&gt;

    &lt;p&gt;상세화수준이 code로 포현할 수 밖에 없게될 때 coding phase로 넘어간다.&lt;/p&gt;

    &lt;p&gt;이 phase에서는 data structure도 정의하게 되는데, data structure를 정의할 때 유의할 점은 &lt;a href=&quot;/aps/2020/05/26/solution-model.html&quot;&gt;여기&lt;/a&gt;를 참고한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;모든 문제에 이 방법으로 접근한다면, 태산같은 문제를 만났을때 망연자실하고 있지만은 않을 것 같다.&lt;/p&gt;
</description>
        <pubDate>Mon, 25 May 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/aps/2020/05/25/aps-process.html</link>
        <guid isPermaLink="true">http://localhost:4000/aps/2020/05/25/aps-process.html</guid>
        
        
        <category>aps</category>
        
      </item>
    
      <item>
        <title>MathJax로 Jekyll blog에 수학식 표현하기</title>
        <description>&lt;ol&gt;
  &lt;li&gt;_config.yml
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;markdown: kramdown
highlighter: rouge
lsi: false
excerpt_separator: &quot;\n\n&quot;
incremental: false
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;_includes/mathjax_support.html
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;script type=&quot;text/x-mathjax-config&quot;&amp;gt;
 MathJax.Hub.Config({
TeX: {
  equationNumbers: {
    autoNumber: &quot;AMS&quot;
  }
},
tex2jax: {
  inlineMath: [ ['$', '$'] ],
  displayMath: [ ['$$', '$$'] ],
  processEscapes: true,
}
 });
 MathJax.Hub.Register.MessageHook(&quot;Math Processing Error&quot;,function (message) {
alert(&quot;Math Processing Error: &quot;+message[1]);
 });
 MathJax.Hub.Register.MessageHook(&quot;TeX Jax - parse error&quot;,function (message) {
alert(&quot;Math Processing Error: &quot;+message[1]);
 });
&amp;lt;/script&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot; async
     src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML&quot;&amp;gt;
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;_layouts/post.html
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{ % if page.use_math % }
  { % include mathjax_support.html % }
{ % endif % }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;posting example
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;---
layout: post
title: &quot;MathJax로 Jekyll blog에 수학식 표현하기&quot;
use_math: true
---
   
Standard normal distribution: $\phi(x) = \frac{1}{2\pi}\varepsilon^{\frac{-x^2}{2}}$ is an example.
   
$$
\phi(x) = \frac{1}{2\pi}\varepsilon^{\frac{-x^2}{2}}
$$
   
$$
E = mc^2
$$
   
$$
e^{i\pi} + 1 = 0
$$
   
$$
v(t) = v_{peak}\sin(\omega t)
$$
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;Standard normal distribution: $\phi(x) = \frac{1}{2\pi}\varepsilon^{\frac{-x^2}{2}}$ is an example.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\phi(x) = \frac{1}{2\pi}\varepsilon^{\frac{-x^2}{2}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;E = mc^2&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;e^{i\pi} + 1 = 0&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;v(t) = v_{peak}\sin(\omega t)&lt;/script&gt;
</description>
        <pubDate>Tue, 05 May 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2020/05/05/Jekyll-Mathjax.html</link>
        <guid isPermaLink="true">http://localhost:4000/2020/05/05/Jekyll-Mathjax.html</guid>
        
        
      </item>
    
      <item>
        <title>Emacs에서 remote host의 파일 편집하기</title>
        <description>&lt;p&gt;이맥스로 편집기를 갈아타기로 결정하고 난 후 여러 환경에서도 이맥스를 사용하고자 했다.
(이맥스는 편집기뿐 아니라 실행, 디버깅까지 할 수 있는 통합개발환경으로 사용할 수 있고
마크다운, 레이텍, 플랜트 유엠엘, 피디에프/이미지 뷰어, 깃클라이언트 등으로 사용할 수 있다.)&lt;/p&gt;

&lt;p&gt;수년 전 부터 회사의 개발 환경이 리눅스로 바뀌고 있었고, 요즘은 고성능 리눅스 서버에 접속해서 개발을 하고 있다.
하지만 문서작업과 인프라는 윈도우를 사용할 수 밖에 없는 상황이어서, 개인 로컬피씨 오에스는 윈도우 일 수 밖에 없는 상황이다.&lt;/p&gt;

&lt;p&gt;이 경우 이맥스를 적용할 수 있는 시나리오는 두 가지이다.(콘솔 버전의 이맥스 사용은 배제한다.)&lt;/p&gt;

&lt;p&gt;첫째는 엑스 서버를 지원하는 터미널 프로그램으로 서버에 접속해 이맥스를 실행하는 방법이다. 서버에서 실행한 이맥스 윈도우가 로컬피씨에서 보이게 되는 것이다. 이 방법은 특별한 가이드 필요없고, 당연히 가장 쉬운 방법이다. &lt;br /&gt;
지금은 이 방법을 사용하고 있지만, 이 경우 서버에 엑스윈도우 데스크탑이 설치되어 있어야 한다.&lt;/p&gt;

&lt;p&gt;두번째는 로컬호스ㅌ에서 실행시킨 이맥스에서 서버로 접속해 파일을 편집하는 방법이다. 디렉토리 뷰를 통해 서버에 접속하는 방법이다. 이맥스에서 아래의 커맨드 라인을 이용해 서버에 접근할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;C-x d /scp:&amp;lt;user&amp;gt;@&amp;lt;host&amp;gt;:&amp;lt;path to dir or file&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sun, 09 Jun 2019 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/emacs/2019/06/09/emacs-remote-files.html</link>
        <guid isPermaLink="true">http://localhost:4000/emacs/2019/06/09/emacs-remote-files.html</guid>
        
        
        <category>emacs</category>
        
      </item>
    
      <item>
        <title>Running X Window app from docker container</title>
        <description>&lt;p&gt;Server에서 개발을 하다보면 필요한 패키지를 설치해야 하거나, 사용해보고 싶은 서비스를 설치하거나 자신에게 맞는 개발 환경을 구성하고 싶을 때가 있다. 이 때마다 관리자에게 요청을 할 수도 없고, 하더라도 거부당 할 수 있다.&lt;/p&gt;

&lt;p&gt;그래서 배포를 위해 docker를 사용하기도 하지만, 개발환경을 구성하기 위해 더 많이 사용하고 있다.&lt;/p&gt;

&lt;p&gt;개인적인 기호겠지만, 서버 호스트에는 최소한의 공통 package만 설치, docker권한을 부여 후, 나머지는 customize된 환경을 사용할 수 있도록 하는 것이 서버의 안정성 및 사용성에 가장 좋은 운영 방안인 것 같다.&lt;/p&gt;

&lt;p&gt;간혹 X Window GUI app을 docker에 설치해 사용해야 하는 경우가 있는데, docker container를 만들 때 지정하는 option만으로 docker container의 X window app을 host에 띄울 수 있다.&lt;br /&gt;
단, Host에 X Window가 설치되어 있어야 한다.&lt;/p&gt;

&lt;p&gt;이 예시는 Ubuntu 16.04를 기준으로 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Host에는 X Window가 설치되어 있어야 하고,&lt;/li&gt;
  &lt;li&gt;환경변수 &lt;strong&gt;DISPLAY&lt;/strong&gt; 가 정의돼 있어야 한다.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;$HOME/.Xauthority file&lt;/em&gt; 이 있어야 한다.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;--net=host&lt;/em&gt; 사용해야 한다.&lt;/li&gt;
  &lt;li&gt;Example command line&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run -it --rm 
--security-opt seccomp:unconfied 
--cap-add=ALL --privileged
-e DISPLAY=$DISPLAY
-v $HOME/.Xauthority:/home/user/.Xauthority:rw 
--net=host 
&amp;lt;image&amp;gt;
&amp;lt;command&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;note) &lt;em&gt;--rm&lt;/em&gt; option은 image, container사이의 coherency 유지를 위해 사용한다.&lt;br /&gt;
&lt;em&gt;--security-opt seccomp:unconfied --cap-add=ALL --privileged&lt;/em&gt; 은 &lt;strong&gt;gdb&lt;/strong&gt; 사용을 위한 option이다.&lt;/p&gt;
</description>
        <pubDate>Mon, 15 Apr 2019 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/dev/2019/04/15/docker-xwingui.html</link>
        <guid isPermaLink="true">http://localhost:4000/dev/2019/04/15/docker-xwingui.html</guid>
        
        
        <category>dev</category>
        
      </item>
    
      <item>
        <title>how to get bazel work behind proxy</title>
        <description>&lt;p&gt;proxy를 통해 network에 접속하는 환경에서 bazel을 사용할 때, 인증서 문제로 source build할 수 없는 상황에 맞닥뜨리게 된다. 처음에는 firewall문제로 인식하고 local cache를 사용하는 등의 방법으로 우회를 고민하게 된다. 그런 개발 환경에서의 개발은 절름발이 신세를 빠져나오지 못한다.&lt;br /&gt;
절름발이 신세를 빠져나온 길의 기록이다.&lt;/p&gt;

&lt;p&gt;proxy뒤에서 bazel build를 시도하면 이런 error message를 만나게 된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 에러는 bazel아니라, JVM의 error message로 target URL의 인증서를 찾을 수 없다는 error다.&lt;br /&gt;
따라서, Bazel이 실행되는 JVM의 certificate 환경을 자신의 proxy에 맞춰주면 된다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;install certificate for a site&lt;br /&gt;
  대부분 proxy 뒤에 위치한 서버라면 기본적으로 Proxy에 대한 인증서가 설치되어 있을 것이다.
  해당 서버에서 browser를 통해 문제가 되는 파일 혹은 사이트에 접근이 된다면 인증서 설정이 되어있는 상태이고, 이 단계는 건너띄어도 된다.&lt;br /&gt;
  만약 설치가 되어있지 않은 환경이라면 다음과 같은 과정을 통해 인증서를 설치한다.&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;Download InstallCert.java code from &lt;a href=&quot;https://jonelove.tistory.com/entry/JAVA-SSL-PKIX-path-building-failed-%EC%98%A4%EB%A5%98%EC%8B%9C&quot;&gt;somewhere&lt;/a&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;create jar file
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ javac InstallCert.java
$ manifet.txt:
$ Main-class: InstallCert
$ jar -cvmf manifest.txt InstallCert.jar *.class
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;download cetificates
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ java -jar InstallCert.jar &amp;lt;URL-you-want-to-access&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;export to file from local keystore
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ keytool -exportcert -keystore jssecacerts -storepass changeit -file output.cert -alias &amp;lt;your-alias-name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;import to JAVA keystore
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ keytool -importcert -keystore ${JAVA_HOME}/jre/lib/security/cacerts -storepass changeit -file output.cert -alias &amp;lt;letsencrypt&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;proxy awareness &lt;strong&gt;bazel&lt;/strong&gt;&lt;br /&gt;
  인증서가 system에 정상 설치되어 있더라도, JVM이 proxy용 인증서를 사용하도록 해야 한다.&lt;br /&gt;
  (JVM 기본 설정은 proxy가 없는 상태를 전제로 설정된 것으로 보인다.)&lt;br /&gt;
  JVM에 인증서 위치(trustStore, keyStore)를 override하는 option은 다음과 같다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-Djavax.net.ssl.trustStore=&amp;lt;your-path-to-trustStorea&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;&lt;strong&gt;bazel&lt;/strong&gt;은 &lt;em&gt;–host_jvm_args&lt;/em&gt; option을 통해 JVM option을 전달 받는다.&lt;br /&gt;
  따라서 다음의 command line으로 proxy 뒤에서도 정상적으로 bazel을 사용할 수 있다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ bazel --host_jvm_args=‘-Djavax.net.ssl.trustStore=$path-to-truststore’ build &amp;lt;your-build-target&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Annex
    &lt;ol&gt;
      &lt;li&gt;more java option&lt;br /&gt;
  java app인 경우. http.proxyHost option으로는 부족할 때가 있다. (정확히 어떤 경우인지는 FFS이다.)&lt;br /&gt;
  이 때, 다음 option을 사용해 볼 수 있다.
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-Djava.net.useSystemProxies=true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;em&gt;JAVA_HOME&lt;/em&gt; of OSX
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sun, 14 Apr 2019 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/tensorflow/2019/04/14/bazel-behind-proxy.html</link>
        <guid isPermaLink="true">http://localhost:4000/tensorflow/2019/04/14/bazel-behind-proxy.html</guid>
        
        
        <category>tensorflow</category>
        
      </item>
    
      <item>
        <title>필사 방법 정리</title>
        <description>&lt;p&gt;글쓰기 공부를 위한 필사 방법을 정리.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;필사할 글은 본인이 직접 고른다.&lt;/li&gt;
  &lt;li&gt;먼저 쓱 읽는다.&lt;/li&gt;
  &lt;li&gt;몇 번 읽어서 전체 글이 무엇을 말하고자 하는지 파악한다.&lt;/li&gt;
  &lt;li&gt;필사를 하면서 단어, 문장 구조, 문장 접속 구조를 익힌다.
    &lt;ul&gt;
      &lt;li&gt;필사할 때는 가능한 문장 단위로 필사한다.&lt;/li&gt;
      &lt;li&gt;문장이 길면 가능한 가장 긴 의미 단위로 필사한다.&lt;/li&gt;
      &lt;li&gt;필사할 때는 자신이 문장을 작성한다는 생각으로 쓴다. 작성 후 원문과 비교해서 단어, 문장 구조등을 익힌다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;4번의 과정으로 문장 구조가 눈에 들어오면, 문단 구조, 문단 접속 구조로 넘어간다.&lt;/li&gt;
  &lt;li&gt;5번의 과정이 익숙해 지면, 글 전체 구조를 파악하는 단계로 넘어간다.&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Wed, 14 Feb 2018 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/writing/2018/02/14/my-transciption.html</link>
        <guid isPermaLink="true">http://localhost:4000/writing/2018/02/14/my-transciption.html</guid>
        
        
        <category>writing</category>
        
      </item>
    
  </channel>
</rss>
