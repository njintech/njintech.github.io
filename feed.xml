<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>tesigners</title>
    <description></description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 03 Jun 2020 21:09:53 +0900</pubDate>
    <lastBuildDate>Wed, 03 Jun 2020 21:09:53 +0900</lastBuildDate>
    <generator>Jekyll v3.7.2</generator>
    
      <item>
        <title>StepwiseRefine(4) - N Queens by recursion</title>
        <description>&lt;p&gt;&lt;em&gt;Niklaus Wirth, Program Development by Stepwise Refinement&lt;/em&gt;의 예제인 8-Queens 문제를 &lt;a href=&quot;/aps/2020/05/25/aps-process.html&quot;&gt;알고리즘 문제해결 process&lt;/a&gt;에서 정리한 방법을 따라 풀어가는 과정을 정리한다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/aps/2020/06/03/stepwiserefine-nqueens-loop.html&quot;&gt;loop을 통한 구현&lt;/a&gt;에 이어서, recusion procedure을 이용해 구현해 본다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Implementation 1
    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;analysis&lt;/p&gt;

        &lt;p&gt;여기서 제안된 방법은 비어있는 보드(?) 혹은 보드가 없는 상태에서, 보드를 한 단계씩 확장하면서 문제를 해결해 나갈 수 있다는 관점에서 시작한다.
 (해답의 유형에 따라 이 방법이 유효한다.)&lt;/p&gt;

        &lt;p&gt;각 단계는 queen이 안전하게 위치할 수 있는 한 개의 solution을 확보하는 것이고, 8개 column으로 확장할때 까지 이어진다.&lt;/p&gt;

        &lt;p&gt;이 확장 process는 Dijkstra에 의해 공식화(formulated)되어 있으며, recusion을 이용해 표현할 수 있다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;model/design solution&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; trycolumn(j) {
     i = 0
            
     while !safe and i==8
         test_square()
                
         if (safe)
             set_queen()
             x[j] = i
                    
             if (j &amp;lt; 8) trycolumn(j)
             if (!safe) remove_queen()
 }
        
 main() {
     trycolumn(1)
     if safe
         print(x)
     else
         print('fail')
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;program solution&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; #include &amp;lt;iostream&amp;gt;
 using namespace std;
        
 int pointer[9] = {0, };
        
 int a[9] = {0, };
 int b[30] = {0, };
 int c[30] = {0, };
        
 int test_square(int step, int row)
 {
     int square = row;
            
     int safe = a[square] | b[step + square] | c[step - square + 8];
            
     return !safe;
 }
        
 void set_queen(int step, int row)
 {
     int square = row;
            
     a[square] = b[step + square] = c[step - square + 8] = true;
 }
        
 void remove_queen(int step)
 {
     int square = pointer[step];
            
     a[square] = b[step + square] = c[step - square + 8] = false;
 }
        
 bool last_square(int step)
 {
     return pointer[step] == 8;
 }
        
 int tryColumn(int step)
 {
     int safe = 0;
            
     if (step &amp;gt; 8) return true;
            
     for (int i = 1; i &amp;lt;=8; ++i) {
         safe = test_square(step, i);
                
         if (safe) {
             set_queen(step, i);
             pointer[step] = i;
                        
             safe = tryColumn(step + 1);
                        
             if (!safe) remove_queen(step);
             else break;
         }
     }
            
     return safe;
 }
        
 int main(void)
 {
     int safe = 0;
        
     safe = tryColumn(1);
            
     if (safe) {
         cout &amp;lt;&amp;lt; endl;
         for (int i = 1; i &amp;lt; 9; ++i) {
             cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &quot;: &quot; &amp;lt;&amp;lt; pointer[i] &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; endl;
         }
     }
     else cout &amp;lt;&amp;lt; &quot;Failed&quot; &amp;lt;&amp;lt; endl;
            
     return 0;
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Implementation 2
    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;analysis&lt;/p&gt;

        &lt;p&gt;지금까지의 solution은 조건을 만족하는 첫 번째 한개의 답만 찾았다.&lt;/p&gt;

        &lt;p&gt;조건을 만족하는 모든 조합을 찾는 general solution을 도출해 본다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;model/design solution&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;program solution&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; #include &amp;lt;iostream&amp;gt;
 using namespace std;
        
 int pointer[9] = {0, };
        
 int a[9] = {0, };
 int b[30] = {0, };
 int c[30] = {0, };
        
 int solCount = 0;
        
 int test_square(int step, int row)
 {
     int square = row;
        
     int safe = a[square] | b[step + square] | c[step - square + 8];
        
     return !safe;
 }
        
 void set_queen(int step, int row)
 {
     int square = row;
        
     a[square] = b[step + square] = c[step - square + 8] = true;
 }
        
 void remove_queen(int step)
 {
     int square = pointer[step];
        
     a[square] = b[step + square] = c[step - square + 8] = false;
 }
        
 bool last_square(int step)
 {
     return pointer[step] == 8;
 }
        
 int tryColumn(int step)
 {
     int safe = 0;
        
     if (step &amp;gt; 8) {
         solCount += 1;
         for (int i = 1; i &amp;lt; 9; ++i) {
             cout &amp;lt;&amp;lt; pointer[i] &amp;lt;&amp;lt; &quot; &quot;;
         }
         cout &amp;lt;&amp;lt; endl;
        
         return true;
     }
        
     for (int i = 1; i &amp;lt;=8; ++i) {
         safe = test_square(step, i);
        
         if (safe) {
             set_queen(step, i);
             pointer[step] = i;
        
             safe = tryColumn(step + 1);
        
             remove_queen(step);
         }
     }
        
     return safe;
 }
        
 int main(void)
 {
     int safe = 0;
        
     safe = tryColumn(1);
        
     cout &amp;lt;&amp;lt; &quot;Sol Count: &quot; &amp;lt;&amp;lt; solCount &amp;lt;&amp;lt; endl;
     return 0;
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Wed, 03 Jun 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/aps/2020/06/03/stepwiserefine-nqueens-recursion.html</link>
        <guid isPermaLink="true">http://localhost:4000/aps/2020/06/03/stepwiserefine-nqueens-recursion.html</guid>
        
        
        <category>aps</category>
        
      </item>
    
      <item>
        <title>StepwiseRefine(3) - N Queens by loop</title>
        <description>&lt;p&gt;&lt;em&gt;Niklaus Wirth, Program Development by Stepwise Refinement&lt;/em&gt;의 예제인 8-Queens 문제를 &lt;a href=&quot;/aps/2020/05/25/aps-process.html&quot;&gt;알고리즘 문제해결 process&lt;/a&gt;에서 정리한 방법을 따라 풀어가는 과정을 정리한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Problem&lt;/p&gt;

    &lt;p&gt;Given are an 8x8 chessboard and 8 queens which are hostile to each other.&lt;/p&gt;

    &lt;p&gt;Find a position for each queen (a configuration) such that no queen may be taken by any other queen.&lt;/p&gt;

    &lt;p&gt;(i.e. such that every row, column and diagonal contains at most one queen)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Problem analysis phase&lt;/strong&gt;&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;analysis problem&lt;/p&gt;

        &lt;p&gt;condition $p$ : every row, column and diagonal contains at most one queen&lt;/p&gt;

        &lt;p&gt;8x8 chess판에서 condition $p$ 를 만족하는 8개의 위치를 찾는 것이 문제이다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;model/design solution&lt;/p&gt;

        &lt;p&gt;solution $x$ 는 다음과 같이 표현할 수 있다.&lt;/p&gt;

        &lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;x = 8 \ locs \in \{A \cap p(x)\}&lt;/script&gt;
 &lt;script type=&quot;math/tex&quot;&gt;where\ loc = (row, col)&lt;/script&gt;&lt;/p&gt;

        &lt;script type=&quot;math/tex; mode=display&quot;&gt;where\ A=all\ position\ of\ chess, 8 \times 8&lt;/script&gt;

        &lt;p&gt;analytic solution이 존재하지 않는 문제로, trial error방법으로 답을 찾아가야 한다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;program solution&lt;/p&gt;

        &lt;p&gt;trial and error 전략으로 문제를 해결하는  pseudo code는 다음과 같다. 문제 공간은 모든 경우의 수가 되고, 이를 검색하고 조건을 확인해 답을 구하게 된다.&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; do
     x = generate_next_cand(A)
 while p(x) or (no more elements in A) 
     
 if p(x)
       solution = x; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Architecture decision phase-1&lt;/strong&gt;&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;analysis&lt;/p&gt;

        &lt;p&gt;초기 구현의 complexity를 분석해보면&lt;/p&gt;

        &lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;complexity = _{64}\mathrm{C}_{8} = \frac{64!}{56! \times 8!} \approx 2^{32}&lt;/script&gt;
 로 제한 시간 1sec을 만족하지 못 한다.&lt;/p&gt;

        &lt;p&gt;note) 제한시간 1sec은 대략 complexity $10^9$ 정도 이다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;model/design solution&lt;/p&gt;

        &lt;p&gt;초기 구현은 모든 경우의 수를 탐색하는 방법으로 불필요한 경우의 수까지 탐색하고 있다.&lt;/p&gt;

        &lt;p&gt;이 경우, 불필요한 문제영역을 제거함으로써, 그 공간을 줄이는 방법을 적용해 성능을 제고할 수 있다.&lt;/p&gt;

        &lt;p&gt;문제 공간을 줄이는 방법으로 &lt;strong&gt;strategy of preselection&lt;/strong&gt;을 적용해볼 수 있다.&lt;/p&gt;

        &lt;p&gt;$p = q \cap r$ 인 $q$ 와 $r$ 을 다음과 같이 정의할 수 있다.&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;$r$ : in every column, there must be one queen&lt;/li&gt;
          &lt;li&gt;&amp;lt;a name=“condition-q”&amp;gt; $q$ : in every row and diagonal, there must be one queen&lt;/li&gt;
        &lt;/ul&gt;

        &lt;p&gt;이 때, preselected set은 다음과 같이 정의된다.&lt;/p&gt;

        &lt;script type=&quot;math/tex; mode=display&quot;&gt;B_r = \{x | (x \in A) \wedge r(x)\}&lt;/script&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;a name=&quot;aph1-program-solution&quot;&gt;program solution&lt;/a&gt;&lt;/p&gt;

        &lt;p&gt;문제 공간만 줄어들 뿐, trial and error와 동일하다.&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;do 
    x = generate_next_candidate(Br)
while q(x) || empty(Br)

if q(r)
    solution = x
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Architecture decision phase 2&lt;/strong&gt;&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;analysis&lt;/p&gt;

        &lt;p&gt;&lt;a href=&quot;#aph1-program-solution&quot;&gt;두 번째 solution&lt;/a&gt;의 complexity분석은 다음과 같다.&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;$B_r$ 의 크기(complexity)는 condition $r$ 의 정의에 따라, 8개 각 column별 8개의 row가 가능한 조합이므로&lt;/p&gt;

            &lt;script type=&quot;math/tex; mode=display&quot;&gt;8^8 = (2 ^ 3)^8 = 2^{24}&lt;/script&gt;
          &lt;/li&gt;
        &lt;/ul&gt;

        &lt;p&gt;이 된다.&lt;/p&gt;

        &lt;p&gt;하지만, 명백히 성립되지 않는 조합에 대해서도 $q(x)$ check를 수행하고 있다. 예를 들어 $x = x[0], x[1], x[2], …, x[7]$ 이라고 했을 때, $x[1]$ 이 $q(x)$ 를 만족하지 못하면, $x[2], …, x[7]$ 는 명백하게 해답이 될 수 없음에도 탐색을 하게 된다.&lt;/p&gt;

        &lt;p&gt;이 점을 문제로 정의할 수 있다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;model/design solution&lt;/p&gt;

        &lt;p&gt;8 queens solution은&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;${x1, x2, …, x8}$ 의 형식으로 ${x1, …, xj}$ 의 &lt;em&gt;trial solution&lt;/em&gt;을 만들 수 있고&lt;/li&gt;
          &lt;li&gt;&lt;em&gt;trial solution&lt;/em&gt;이 실패하면, 해당 &lt;em&gt;trial solution&lt;/em&gt;의 extension도 fail하게 된다.&lt;/li&gt;
        &lt;/ul&gt;

        &lt;p&gt;즉, back tracking 적용이 가능한 solution type이다. &lt;a href=&quot;/aps/2020/05/26/solution-model.html&quot;&gt;참조&lt;/a&gt;&lt;/p&gt;

        &lt;p&gt;back tracking template code는 다음과 같다.&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; j = 1
 do 
     result = try_step(j)
     if result == successful
        advance(j + 1)
     else
        regress(j - 1)
 while (j &amp;lt; 1) || (j &amp;gt; n)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;program solution&lt;/p&gt;

        &lt;p&gt;back tracking code template을 도입한 첫번째 solution code는 다음과 같다.&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; board
 pointer
 safe

 consider_first_column()

 while not last_col_done and not regress_outof_firstcol
     safe = trycolumn()
            
     if safe
         set_queen()
         consider_next_column()
    else
         regress()

 if last_step_done()
     print(board)
 else
     print(&quot;failed&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Elaboration phase 0&lt;/strong&gt;
    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;analysis&lt;/p&gt;

        &lt;p&gt;backtracking의 핵심인 trystep()과  regress()를 상세화 한다.&lt;/p&gt;

        &lt;p&gt;이 때, stepwise construction이 가능해야 한다는 것을 염두에 두어야 한다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;model/design solution&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;program solution&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; trystep(step) {
     while not(safe) and not(last_square)
         safe = test_square(step, pointer)
         advance_pointer()
              
     return safe
 }
      
 regress(step, pointer) {
     reconsider_prior_step()
            
     if not(regress_outof_firststep)
         removequeen()
                        
     // 하나의 row에 하나의 퀸만 가능하므로, regress한 위치가 마지막 row이면, 
     // 다시 시도해도 safe가 없을것이 자명하므로 한 step더 뒤로 돌아간다.
     // 확인해봐야 함.
            
     if last_square()
         reconsider_prior_column()
         if not(regres_outof_firststep())
             removequeen()                        
 }
      
 main() {
     board: let 8x8 array
     pointer: let array of 1x8
     safe: variable
            
     consider_first_step()
     while not last_col_done and  not regress_outof_firststep
         if trystep() == safe
             set_queen()
             consider_next_step()
         else
             regress()
                
     if last_col_done
         print(x)
     else
         print('fail')
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Coding phase 0&lt;/strong&gt;
    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;analysis&lt;/p&gt;

        &lt;p&gt;elaboration의 수준이 code로 포현할 수 밖에 없게될 때 coding phase로 넘어간다.&lt;/p&gt;

        &lt;p&gt;이 단계에서는 다음과 같은 상세화를 진행한다.&lt;/p&gt;

        &lt;p&gt;data structure를 정의할 때 유의할 점은 &lt;a href=&quot;/aps/2020/05/26/solution-model.html&quot;&gt;여기&lt;/a&gt;를 참고한다.&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;data structure 정의&lt;/li&gt;
          &lt;li&gt;간단한 변수의 데이터 타입정의 및 관련 method 상세화&lt;/li&gt;
          &lt;li&gt;step과 pointer 정의&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;model/design solution&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;program solution&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; board
 int step (0 &amp;lt;= step &amp;lt;= 9)
 int pointer[1:8] 
        
 consider_first_column() {
     step = 1
     pointer[1] = 0
 }
        
 consider_next_step(step) {
     step = step + 1
     pointer[step] = 0
 }
        
 advance_pointer(step) {
     pointer[step] += 1
 }
        
 reconsider_prior_step(step) {
     step = step - 1
 }
        
 regress_outof_firststep(step) {
     return step &amp;lt; 1
 }
        
 last_step_done(step) {
     return step &amp;gt; 8
 }
          
 last_square(step) {
     return pointer[step] &amp;gt; 8
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Coding phase 1&lt;/strong&gt;
    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;analysis&lt;/p&gt;

        &lt;p&gt;상세화되지 않는 function중 &lt;em&gt;test_square()&lt;/em&gt;는 가장 자주 불리는 함수고, 가장 비싼 함수다. 따라서, 이 함수가 성능을 좌우하게 된다.&lt;/p&gt;

        &lt;p&gt;각 column의 8개의 row를 loop으로 검사할 수도 있지만, 조사할 조건의 특성, 주어진 문제의 특징을 이용해 자료구조를 정의하면 간단한 연산 한번으로 조사를 할 수 있다.&lt;/p&gt;

        &lt;p&gt;다음과 같이 주어진 조건 &lt;a href=&quot;#condition-q&quot;&gt;q(x)&lt;/a&gt;와 좌표 특성을 이용하여      자료구조를 정의한다.&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;같은 /-diagonal에 위치한 %loc(row, col)%는 %val = row + col%이 같은 값을 가진다.&lt;/li&gt;
          &lt;li&gt;같은 -diagoal에 위치한 %loc(row, col)%은 %val = row - col%이 같은 값을 가진다.&lt;/li&gt;
        &lt;/ul&gt;

        &lt;p&gt;자료구조는 다음과 같이 정의할 수 있다.&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;a[1:8] = true: no queen is positioned in row&lt;/li&gt;
          &lt;li&gt;b[2:16] = true: no queen is positioned in the /-diagonal&lt;/li&gt;
          &lt;li&gt;c[-7:7] = true: no queen is positioned in the -diagonal&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;model/design solution&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;program solution&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; test_square(step, pointer) {
     safe = a[pointer] or b[step + pointer] or c[step - pointer]
     return safe
 }
                
 set_queen(step, pointer) {
     a[pointer] = b[step + pointer] = c[step - pointer] = false
 }
    
 remove_queen(step) {
     a[pointer] = b[step + pointer] = c[step - pointer] = false
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Coding phase 2&lt;/strong&gt;
    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;analysis&lt;/p&gt;

        &lt;p&gt;상세화된 결과를 모두 합친 entire code 도출한다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;model/design Solution&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;program solution&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; int step (0 &amp;lt;= step &amp;lt;= 9)
 int pointer[1:8] 
 a[1:8] = true: no queen is positioned in row
 b[2:16] = true: no queen is positioned in the /-diagonal
 c[-7:7] = true: no queen is positioned in the \-diagonal
        
 consider_first_column() {
     step = 1
     pointer[1] = 0
 }
    
 consider_next_step(step) {
     step = step + 1
     pointer[step] = 0
 }
    
 advance_pointer(step) {
     pointer[step] += 1
 }
    
 reconsider_prior_step(step) {
     step = step - 1
 }
    
 regress_outof_firststep(step) {
     return step &amp;lt; 1
 }
    
 last_step_done(step) {
     return step &amp;gt; 8
 }
    
 last_square(step) {
     return pointer[step] &amp;gt; 8
 }
    
 test_square(step, pointer) {
     safe = a[pointer] or b[step + pointer] or c[step - pointer]
     return safe
 }
            
 set_queen(step, pointer) {
     a[pointer] = b[step + pointer] = c[step - pointer] = false
 }
            
 remove_queen(step) {
     a[pointer] = b[step + pointer] = c[step - pointer] = false
 }

 main() {
     board: let 8x8 array
     pointer: let array of 1x8
     safe: variable
            
     consider_first_step()
            
     while last_col_done or regress_outof_firststep {
         if trystep() == safe
             set_queen()
             consider_next_step()
         else
             regress()
     }
                
     if last_col_done
         print(x)
     else
         print('fail')
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Implementation 1&lt;/strong&gt;
    &lt;ol&gt;
      &lt;li&gt;analysis&lt;/li&gt;
      &lt;li&gt;model/design solution&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;program solution&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; #include &amp;lt;iostream&amp;gt;
 using namespace std;
        
 int step = 1;
 int row = 0;
        
 int pointer[9] = {0, };
        
 int a[9] = {0, };
 int b[30] = {0, };
 int c[30] = {0, };
        
 int test_square(int row)
 {
     int square = row;
            
     int safe = a[square] | b[step + square] | c[step - square + 8];
            
     return !safe;
 }
        
 void set_queen(int row)
 {
     int square = row;
            
     a[square] = b[step + square] = c[step - square + 8] = true;
 }
        
 void remove_queen(void)
 {
     int square = pointer[step];
            
     a[square] = b[step + square] = c[step - square + 8] = false;
 }
        
 bool last_square()
 {
     return pointer[step] &amp;gt; 8;
 }
        
 void regress(void)
 {
     step -= 1;
            
     if (step &amp;gt;= 1) {
         remove_queen();
                
         if (last_square()) {
             step -= 1;
                    
             if (step &amp;gt;= 1) remove_queen();
         }
     }
 }
        
 int main(void)
 {
     /*
      * try step
      */
     while ((step &amp;lt;= 8) &amp;amp;&amp;amp; (step &amp;gt;= 1)) {
         int safe = 0;
                
         while (!safe &amp;amp;&amp;amp; (row != 8)) {
             row += 1;
                    
             safe = test_square(row);
         }
                
         if (safe) {
             set_queen(row);
                    
             pointer[step] = row;
                    
             step += 1;
             row = 0;
         }
         else {
             regress();
             row = pointer[step];
         }
     }
            
     if (step &amp;gt; 8) {
         cout &amp;lt;&amp;lt; endl;
         for (int i = 1; i &amp;lt; 9; ++i) {
             cout &amp;lt;&amp;lt; pointer[i] &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; endl;
         }
     }
     else cout &amp;lt;&amp;lt; &quot;Failed&quot; &amp;lt;&amp;lt; endl;
            
     return 0;
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Implementation 2&lt;/strong&gt;
    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;analysis&lt;/p&gt;

        &lt;p&gt;global variable인 &lt;em&gt;step&lt;/em&gt;을 parameter전달로 local variable로 만든다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;model/design solution&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;program solution&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; #include &amp;lt;iostream&amp;gt;
 using namespace std;
        
 int pointer[9] = {0, };
        
 int a[9] = {0, };
 int b[30] = {0, };
 int c[30] = {0, };
        
 int test_square(int step, int row)
 {
     int square = row;
            
     int safe = a[square] | b[step + square] | c[step - square + 8];
            
     return !safe;
 }
        
 void set_queen(int step, int row)
 {
     int square = row;
            
     a[square] = b[step + square] = c[step - square + 8] = true;
 }
        
 void remove_queen(int step)
 {
     int square = pointer[step];
            
     a[square] = b[step + square] = c[step - square + 8] = false;
 }
        
 bool last_square(int step)
 {
     return pointer[step] &amp;gt; 8;
 }
        
 int regress(int step)
 {
     step -= 1;
            
     if (step &amp;gt;= 1) {
         remove_queen(step);
                
         if (last_square(step)) {
             step -= 1;
                    
             if (step &amp;gt;= 1) remove_queen(step);
         }
     }
            
     return step;
 }
        
 int main(void)
 {
     int row = 0;
     int step = 1;
            
     /*
      * try step
      */
     while ((step &amp;lt;= 8) &amp;amp;&amp;amp; (step &amp;gt;= 1)) {
         int safe = 0;
                
         while (!safe &amp;amp;&amp;amp; (row != 8)) {
             row += 1;
                    
             safe = test_square(step, row);
         }
                
         if (safe) {
             set_queen(step, row);
                    
             pointer[step] = row;
                    
             step += 1;
             row = 0;
         }
         else {
             step = regress(step);
             row = pointer[step];
         }
     }
            
     if (step &amp;gt; 8) {
         cout &amp;lt;&amp;lt; endl;
         for (int i = 1; i &amp;lt; 9; ++i) {
             cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &quot;: &quot; &amp;lt;&amp;lt; pointer[i] &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; endl;
         }
     }
     else cout &amp;lt;&amp;lt; &quot;Failed&quot; &amp;lt;&amp;lt; endl;
            
     return 0;
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Post mortem&lt;/strong&gt;
    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;analysis&lt;/p&gt;

        &lt;p&gt;지금까지의 solution은 조건을 만족하는 첫 번째 한개의 답만 찾았다.&lt;/p&gt;

        &lt;p&gt;조건을 만족하는 모든 조합을 찾는 general solution을 도출해 본다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;model/design solution&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;program solution&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; #include &amp;lt;iostream&amp;gt;
 using namespace std;
        
 int pointer[9] = {0, };
        
 int a[9] = {0, };
 int b[30] = {0, };
 int c[30] = {0, };
        
 int test_square(int step, int row)
 {
     int square = row;
            
     int safe = a[square] | b[step + square] | c[step - square + 8];
            
     return !safe;
 }
        
 void set_queen(int step, int row)
 {
     int square = row;
            
     a[square] = b[step + square] = c[step - square + 8] = true;
 }
        
 void remove_queen(int step)
 {
     int square = pointer[step];
            
     a[square] = b[step + square] = c[step - square + 8] = false;
 }
        
 bool last_square(int step)
 {
     return pointer[step] &amp;gt; 8;
 }
        
 int regress(int step)
 {
     step -= 1;
            
     if (step &amp;gt;= 1) {
         remove_queen(step);
                
         if (last_square(step)) {
             step -= 1;
                    
             if (step &amp;gt;= 1) remove_queen(step);
         }
     }
            
     return step;
 }
        
 int main(void)
 {
     int row = 0;
     int step = 1;
        
     int solCount = 0;
        
     /*
      * try step
      */
     while (step &amp;gt;= 1) {
         int safe = 0;
                
         while (!safe &amp;amp;&amp;amp; (row != 8)) {
             row += 1;
                    
             safe = test_square(step, row);
         }
                
         if (safe) {
             set_queen(step, row);
                    
             pointer[step] = row;
                    
             step += 1;
             row = 0;
        
             if (step &amp;gt; 8) {
                 solCount += 1;
        
                 for (int i = 1; i &amp;lt; 9; ++i) {
                     cout &amp;lt;&amp;lt; pointer[i] &amp;lt;&amp;lt; &quot; &quot;;
                 }
                 cout &amp;lt;&amp;lt; endl;
        
                 step = regress(step);
                 row = pointer[step];
             }
         }
         else {
             step = regress(step);
             row = pointer[step];
         }
     }
        
     cout &amp;lt;&amp;lt; &quot;Total solutions: &quot; &amp;lt;&amp;lt; solCount &amp;lt;&amp;lt; endl;
     return 0;
 }
        
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Wed, 03 Jun 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/aps/2020/06/03/stepwiserefine-nqueens-loop.html</link>
        <guid isPermaLink="true">http://localhost:4000/aps/2020/06/03/stepwiserefine-nqueens-loop.html</guid>
        
        
        <category>aps</category>
        
      </item>
    
      <item>
        <title>StepwiseRefine(2) - 프로그램 모델링 기법</title>
        <description>&lt;p&gt;&lt;em&gt;Niklaus Wirth, Program Development by Stepwise Refinement&lt;/em&gt; 에서 제시한 solution model 기법 몇가지를 정리한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;model for &lt;strong&gt;Trial and error solution type&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;해법 유형(solution type)이 아래와 같을 때에는&lt;/p&gt;

    &lt;p&gt;$solution= x \in A \cap p(x)$&lt;/p&gt;

    &lt;p&gt;다음의 프로그램 모델을 적용해 해법을 도출할 수 있다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  do
     x = generate_next_cand(A)
  while p(x) or (no more elements in A) 
     
  if p(x)
      solution = x; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;strategy of preselection&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;전체 문제 공간이 너무 큰 경우, 부분 조건을 선택해 선제적으로 문제 공간을 줄일 수 있다.&lt;/p&gt;

    &lt;p&gt;1번 항목의 전체 문제 공간 $p(x)$ 를 다음과 같이 표현할 수 있을 때&lt;/p&gt;

    &lt;p&gt;$p = q \cap r$&lt;/p&gt;

    &lt;p&gt;$r(x)$ 조건을 전체 문제공간에 선제적으로 적용함으로써 문제공간을 $q(x)$로 줄일 수 있다.&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;B_r = {x | (x \in A) \wedge r(x)}&lt;/script&gt;

    &lt;p&gt;이 때, 조건 $r$ 은 다음과 같아야 한다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;$B_r$ is much smaller than $A$&lt;/li&gt;
      &lt;li&gt;elements of $B_r$ are easily generated&lt;/li&gt;
      &lt;li&gt;condition $q$ is easier to test than $p$.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;이 때, 프로그램 모델을 다음과 같다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; do 
    x = generate_next_candidate(Br)
 while q(x) || empty(Br)

 if q(r)
    solution = x
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;model for &lt;strong&gt;back tracking&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;2번의 과정으로 문제공간을 줄였음에도 불구하고, 특정 유형의 해답의 경우, 명백하게 오답인 것을 알고도 해당 문제공간을 탐색하게 된다. 명백한 오류 공간을 탐색하지 않음으로써, 문제공간을 줄일 수가 있다.&lt;/p&gt;

    &lt;p&gt;이 문제를 해결하는 프로그램 모델이 back tracking이다.&lt;/p&gt;

    &lt;p&gt;위에서 말한 특정 유형이란, 해답(solution)이 stepwise construction이 가능한 경우를 말한다. 이를 판단하는 기준은 아래와 같다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; find representation of a trial solution
    
   trial solution = [x1], [x1, x2], .... [x1, x2, ... xj], ..., [x1, x2, ... xn]

   1. full solution can never be obtained by extending a partial trial solution which does not satisfy the predicate.
   2. partial solution satisfying predicate q may not extensible into a complete solution
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;위의 판단 기준에 따라 partial solution을 modeling하면, 다음과 같은 back tracking 프로그램 모델을 적용할 수 있다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; j = 1
 do 
   result = try_step(j)
   if result == successful
     advance(j + 1)
     else
     regress(j - 1)
 while (j &amp;lt; 1) || (j &amp;gt; n)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;note) 여기서 주의해야 할 점은 step j 을 지정해서 trial solution을 지정할 수 있어야 한다. step에 따라 동일한 trial solution을 만들 수 없으면, regression을 할 수가 없다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;data strcture 정의시 유의사항&lt;/p&gt;

    &lt;p&gt;아래는 해당 논문에서 data structure 결정시 유의할 점에 대한 부분을 발췌한 것이다.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;determine data which is key to the solution and how to express them for algorithm use&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;blockquote&gt;
      &lt;ul&gt;
        &lt;li&gt;the success of an algorithm depends almost always on suitable choice of its data representation &lt;strong&gt;in the light of the ease in which this representation allows the necessary operations to be expressed&lt;/strong&gt;.&lt;/li&gt;
        &lt;li&gt;consideration regarding storage requirements may be of prime importance&lt;/li&gt;
        &lt;li&gt;In general, it is advisable to delay decisions about data representation as long as possible&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;위에 정리한 solution type 이외의 유형도 분석해, 이에 적용할 수 있는 프로그램 모델을 추가 조사해야 한다.&lt;/p&gt;
</description>
        <pubDate>Tue, 26 May 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/aps/2020/05/26/solution-model.html</link>
        <guid isPermaLink="true">http://localhost:4000/aps/2020/05/26/solution-model.html</guid>
        
        
        <category>aps</category>
        
      </item>
    
      <item>
        <title>StepwiseRefine(1) - 알고리즘 문제해결 Process</title>
        <description>&lt;p&gt;&lt;em&gt;Niklaus Wirth, Program Development by Stepwise Refinement&lt;/em&gt; 를 참고해서, 알고리즘 문제 해결에 적용할 문제해결 Process를 정리해 본다.&lt;/p&gt;

&lt;p&gt;문제 해결 과정은 아래와 같이 3개 과정으로 정의할 수 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;문제 분셕 (Analysis problem)&lt;/p&gt;

    &lt;p&gt;문제를 분석해 문제가 무엇인지 분석하고, 특정하여 모델링 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;문제 모델링 및 해법 도출 (Model/Design solution)&lt;/p&gt;

    &lt;p&gt;특정된 문제의 해법을 모델링 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;해법 프로그램 (Program solution)&lt;/p&gt;

    &lt;p&gt;설계/해법을 수행할 수 있는 프로그램을 작성하고 검토/검증한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;위의 과정은 알고리즘 문제뿐 아니라, 모든 문제를 해결해 나가는 과정을 간단하게 추상화한 것이다. 이 과정을 문제해결 단계에 맞추어 적용하고 운용하는 것이 문제해결 능력 향상의 핵심이다.&lt;/p&gt;

&lt;p&gt;우리가 해결하고자 하는 대부분의 문제는 처음부터 구체적으 해결책을 도출하기 힘들다.
이런 추상적인 문제는 구체화하는 과정을 거치고, 구체화된 문제를 작은 문제로 나누면 어럽지않게 문제를 해결해 나갈 수 있다. 위 기본 문제 해결 과정을 문제의 구체화, 세분화 과정에 적용해서 큰 문제를 해결할 수 있다.&lt;/p&gt;

&lt;p&gt;요약하자면, 모든 문제는 analytic solution을 가지고 있거나 atomic 문제가 아닌 경우, 몇개의 작은 문제로 나눌 수 있고 device and conquer로 해결해 나갈 수 있다.&lt;/p&gt;

&lt;p&gt;구체화, 세분화 관점에서 문제 해결 단계를 아래의 4가지 단계로 정의할 수 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Problem analysis phase&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;solution type을 분석해서 기본 해법 pseudo code를 만든다.&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;문제에서 주어진 조건들과 구하고자 하는 답 사이의 관계를 분석하면 기본적인 접근방법을 설정할 수 있다.&lt;/p&gt;

    &lt;p&gt;예를 들어 문제에서 주어진 조건과 구하고자 하는 답 사이에 analytic solution이 존재한다면, 그 해법 알고리즘을 구현한다.
 반면, analytic solution이 존재하지 않는다면, 문제 공간에서 trial and error 정책으로 문제해결에 접근해야 한다.&lt;/p&gt;

    &lt;p&gt;따라서, 이 단계에서는 문제에서 주어진 조건과 답 사이의 관계에 초점을 두고 문제 분석을 진행해, 기본적인 접근방법을 정의하고 그 접근 방법을 pseudo code형태를 정의한다.&lt;/p&gt;

    &lt;p&gt;이 단계에서는 solution type과 그 psudo code 패턴을 알고 있어야 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Architecture decision phase&lt;/p&gt;

    &lt;p&gt;1번 과정에서 도출한 해법은 주어진 문제 해결에만 집중한 결과물로 대부분 시간에 대한 성능을 고려되지 않는다. 물론 경험이 쌓이면, 한 번의 시도로 성능까지 고려한 해법을 도출할 수도 있을 것이다.&lt;/p&gt;

    &lt;p&gt;이 과정에서는, 기본 해법코드의 성능을 문제로 정의한다. 성능은 O() notation을 이용한 complexity로 분석한다.&lt;/p&gt;

    &lt;p&gt;pseudo code의 temporal/spatial complexity를 분석하고 개선할 수 있는 design decision을 내린다. design decision을 반영해 pseudo code를 개선하고, 목표로하는 성능에 도달할때까지 이 과정을 반복한다.&lt;/p&gt;

    &lt;p&gt;이 단계에서는 주어진 문제에 대한 해답을, 주어진 시간/공간 제한내에 해결할 수 있는 기본 틀을 결정하는 것이다. 주어진 시간/공간이라는 &lt;strong&gt;문제&lt;/strong&gt;를 해결하는 단계인 것이다.&lt;/p&gt;

    &lt;p&gt;이 단계에서는 여러 패턴의 코드를 대상으로 complexity를 분석할 수 있는 능력과 그 개선책에 대한 많은 아이디어를 도출할 수 있는 능력이 요구된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Elaboration phase&lt;/p&gt;

    &lt;p&gt;이 단계에 이르면, 문제 해결의 틀(architecture)은 정해진다.&lt;/p&gt;

    &lt;p&gt;이 단계에서는 도출된 문제 해결 프로그램 중 상세화가 필요한 activity를 찾아 자세하게 기술하는 단계이다.&lt;/p&gt;

    &lt;p&gt;이 과정을 통해 세부 동작 및 attribute 등을 도출한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Coding phase&lt;/p&gt;

    &lt;p&gt;상세화수준이 code로 포현할 수 밖에 없게될 때 coding phase로 넘어간다.&lt;/p&gt;

    &lt;p&gt;이 phase에서는 data structure도 정의하게 되는데, data structure를 정의할 때 유의할 점은 &lt;a href=&quot;/aps/2020/05/26/solution-model.html&quot;&gt;여기&lt;/a&gt;를 참고한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;모든 문제에 이 방법으로 접근한다면, 태산같은 문제를 만났을때 망연자실하고 있지만은 않을 것 같다.&lt;/p&gt;
</description>
        <pubDate>Mon, 25 May 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/aps/2020/05/25/aps-process.html</link>
        <guid isPermaLink="true">http://localhost:4000/aps/2020/05/25/aps-process.html</guid>
        
        
        <category>aps</category>
        
      </item>
    
      <item>
        <title>MathJax로 Jekyll blog에 수학식 표현하기</title>
        <description>&lt;ol&gt;
  &lt;li&gt;_config.yml
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;markdown: kramdown
highlighter: rouge
lsi: false
excerpt_separator: &quot;\n\n&quot;
incremental: false
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;_includes/mathjax_support.html
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;script type=&quot;text/x-mathjax-config&quot;&amp;gt;
 MathJax.Hub.Config({
TeX: {
  equationNumbers: {
    autoNumber: &quot;AMS&quot;
  }
},
tex2jax: {
  inlineMath: [ ['$', '$'] ],
  displayMath: [ ['$$', '$$'] ],
  processEscapes: true,
}
 });
 MathJax.Hub.Register.MessageHook(&quot;Math Processing Error&quot;,function (message) {
alert(&quot;Math Processing Error: &quot;+message[1]);
 });
 MathJax.Hub.Register.MessageHook(&quot;TeX Jax - parse error&quot;,function (message) {
alert(&quot;Math Processing Error: &quot;+message[1]);
 });
&amp;lt;/script&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot; async
     src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML&quot;&amp;gt;
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;_layouts/post.html
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{ % if page.use_math % }
  { % include mathjax_support.html % }
{ % endif % }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;posting example
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;---
layout: post
title: &quot;MathJax로 Jekyll blog에 수학식 표현하기&quot;
use_math: true
---
   
Standard normal distribution: $\phi(x) = \frac{1}{2\pi}\varepsilon^{\frac{-x^2}{2}}$ is an example.
   
$$
\phi(x) = \frac{1}{2\pi}\varepsilon^{\frac{-x^2}{2}}
$$
   
$$
E = mc^2
$$
   
$$
e^{i\pi} + 1 = 0
$$
   
$$
v(t) = v_{peak}\sin(\omega t)
$$
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;Standard normal distribution: $\phi(x) = \frac{1}{2\pi}\varepsilon^{\frac{-x^2}{2}}$ is an example.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\phi(x) = \frac{1}{2\pi}\varepsilon^{\frac{-x^2}{2}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;E = mc^2&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;e^{i\pi} + 1 = 0&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;v(t) = v_{peak}\sin(\omega t)&lt;/script&gt;
</description>
        <pubDate>Tue, 05 May 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2020/05/05/Jekyll-Mathjax.html</link>
        <guid isPermaLink="true">http://localhost:4000/2020/05/05/Jekyll-Mathjax.html</guid>
        
        
      </item>
    
      <item>
        <title>Emacs에서 remote host의 파일 편집하기</title>
        <description>&lt;p&gt;이맥스로 편집기를 갈아타기로 결정하고 난 후 여러 환경에서도 이맥스를 사용하고자 했다.
(이맥스는 편집기뿐 아니라 실행, 디버깅까지 할 수 있는 통합개발환경으로 사용할 수 있고
마크다운, 레이텍, 플랜트 유엠엘, 피디에프/이미지 뷰어, 깃클라이언트 등으로 사용할 수 있다.)&lt;/p&gt;

&lt;p&gt;수년 전 부터 회사의 개발 환경이 리눅스로 바뀌고 있었고, 요즘은 고성능 리눅스 서버에 접속해서 개발을 하고 있다.
하지만 문서작업과 인프라는 윈도우를 사용할 수 밖에 없는 상황이어서, 개인 로컬피씨 오에스는 윈도우 일 수 밖에 없는 상황이다.&lt;/p&gt;

&lt;p&gt;이 경우 이맥스를 적용할 수 있는 시나리오는 두 가지이다.(콘솔 버전의 이맥스 사용은 배제한다.)&lt;/p&gt;

&lt;p&gt;첫째는 엑스 서버를 지원하는 터미널 프로그램으로 서버에 접속해 이맥스를 실행하는 방법이다. 서버에서 실행한 이맥스 윈도우가 로컬피씨에서 보이게 되는 것이다. 이 방법은 특별한 가이드 필요없고, 당연히 가장 쉬운 방법이다. &lt;br /&gt;
지금은 이 방법을 사용하고 있지만, 이 경우 서버에 엑스윈도우 데스크탑이 설치되어 있어야 한다.&lt;/p&gt;

&lt;p&gt;두번째는 로컬호스ㅌ에서 실행시킨 이맥스에서 서버로 접속해 파일을 편집하는 방법이다. 디렉토리 뷰를 통해 서버에 접속하는 방법이다. 이맥스에서 아래의 커맨드 라인을 이용해 서버에 접근할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;C-x d /scp:&amp;lt;user&amp;gt;@&amp;lt;host&amp;gt;:&amp;lt;path to dir or file&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sun, 09 Jun 2019 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/emacs/2019/06/09/emacs-remote-files.html</link>
        <guid isPermaLink="true">http://localhost:4000/emacs/2019/06/09/emacs-remote-files.html</guid>
        
        
        <category>emacs</category>
        
      </item>
    
      <item>
        <title>Running X Window app from docker container</title>
        <description>&lt;p&gt;Server에서 개발을 하다보면 필요한 패키지를 설치해야 하거나, 사용해보고 싶은 서비스를 설치하거나 자신에게 맞는 개발 환경을 구성하고 싶을 때가 있다. 이 때마다 관리자에게 요청을 할 수도 없고, 하더라도 거부당 할 수 있다.&lt;/p&gt;

&lt;p&gt;그래서 배포를 위해 docker를 사용하기도 하지만, 개발환경을 구성하기 위해 더 많이 사용하고 있다.&lt;/p&gt;

&lt;p&gt;개인적인 기호겠지만, 서버 호스트에는 최소한의 공통 package만 설치, docker권한을 부여 후, 나머지는 customize된 환경을 사용할 수 있도록 하는 것이 서버의 안정성 및 사용성에 가장 좋은 운영 방안인 것 같다.&lt;/p&gt;

&lt;p&gt;간혹 X Window GUI app을 docker에 설치해 사용해야 하는 경우가 있는데, docker container를 만들 때 지정하는 option만으로 docker container의 X window app을 host에 띄울 수 있다.&lt;br /&gt;
단, Host에 X Window가 설치되어 있어야 한다.&lt;/p&gt;

&lt;p&gt;이 예시는 Ubuntu 16.04를 기준으로 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Host에는 X Window가 설치되어 있어야 하고,&lt;/li&gt;
  &lt;li&gt;환경변수 &lt;strong&gt;DISPLAY&lt;/strong&gt; 가 정의돼 있어야 한다.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;$HOME/.Xauthority file&lt;/em&gt; 이 있어야 한다.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;--net=host&lt;/em&gt; 사용해야 한다.&lt;/li&gt;
  &lt;li&gt;Example command line&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run -it --rm 
--security-opt seccomp:unconfied 
--cap-add=ALL --privileged
-e DISPLAY=$DISPLAY
-v $HOME/.Xauthority:/home/user/.Xauthority:rw 
--net=host 
&amp;lt;image&amp;gt;
&amp;lt;command&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;note) &lt;em&gt;--rm&lt;/em&gt; option은 image, container사이의 coherency 유지를 위해 사용한다.&lt;br /&gt;
&lt;em&gt;--security-opt seccomp:unconfied --cap-add=ALL --privileged&lt;/em&gt; 은 &lt;strong&gt;gdb&lt;/strong&gt; 사용을 위한 option이다.&lt;/p&gt;
</description>
        <pubDate>Mon, 15 Apr 2019 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/dev/2019/04/15/docker-xwingui.html</link>
        <guid isPermaLink="true">http://localhost:4000/dev/2019/04/15/docker-xwingui.html</guid>
        
        
        <category>dev</category>
        
      </item>
    
      <item>
        <title>how to get bazel work behind proxy</title>
        <description>&lt;p&gt;proxy를 통해 network에 접속하는 환경에서 bazel을 사용할 때, 인증서 문제로 source build할 수 없는 상황에 맞닥뜨리게 된다. 처음에는 firewall문제로 인식하고 local cache를 사용하는 등의 방법으로 우회를 고민하게 된다. 그런 개발 환경에서의 개발은 절름발이 신세를 빠져나오지 못한다.&lt;br /&gt;
절름발이 신세를 빠져나온 길의 기록이다.&lt;/p&gt;

&lt;p&gt;proxy뒤에서 bazel build를 시도하면 이런 error message를 만나게 된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 에러는 bazel아니라, JVM의 error message로 target URL의 인증서를 찾을 수 없다는 error다.&lt;br /&gt;
따라서, Bazel이 실행되는 JVM의 certificate 환경을 자신의 proxy에 맞춰주면 된다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;install certificate for a site&lt;br /&gt;
  대부분 proxy 뒤에 위치한 서버라면 기본적으로 Proxy에 대한 인증서가 설치되어 있을 것이다.
  해당 서버에서 browser를 통해 문제가 되는 파일 혹은 사이트에 접근이 된다면 인증서 설정이 되어있는 상태이고, 이 단계는 건너띄어도 된다.&lt;br /&gt;
  만약 설치가 되어있지 않은 환경이라면 다음과 같은 과정을 통해 인증서를 설치한다.&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;Download InstallCert.java code from &lt;a href=&quot;https://jonelove.tistory.com/entry/JAVA-SSL-PKIX-path-building-failed-%EC%98%A4%EB%A5%98%EC%8B%9C&quot;&gt;somewhere&lt;/a&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;create jar file
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ javac InstallCert.java
$ manifet.txt:
$ Main-class: InstallCert
$ jar -cvmf manifest.txt InstallCert.jar *.class
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;download cetificates
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ java -jar InstallCert.jar &amp;lt;URL-you-want-to-access&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;export to file from local keystore
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ keytool -exportcert -keystore jssecacerts -storepass changeit -file output.cert -alias &amp;lt;your-alias-name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;import to JAVA keystore
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ keytool -importcert -keystore ${JAVA_HOME}/jre/lib/security/cacerts -storepass changeit -file output.cert -alias &amp;lt;letsencrypt&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;proxy awareness &lt;strong&gt;bazel&lt;/strong&gt;&lt;br /&gt;
  인증서가 system에 정상 설치되어 있더라도, JVM이 proxy용 인증서를 사용하도록 해야 한다.&lt;br /&gt;
  (JVM 기본 설정은 proxy가 없는 상태를 전제로 설정된 것으로 보인다.)&lt;br /&gt;
  JVM에 인증서 위치(trustStore, keyStore)를 override하는 option은 다음과 같다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-Djavax.net.ssl.trustStore=&amp;lt;your-path-to-trustStorea&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;&lt;strong&gt;bazel&lt;/strong&gt;은 &lt;em&gt;–host_jvm_args&lt;/em&gt; option을 통해 JVM option을 전달 받는다.&lt;br /&gt;
  따라서 다음의 command line으로 proxy 뒤에서도 정상적으로 bazel을 사용할 수 있다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ bazel --host_jvm_args=‘-Djavax.net.ssl.trustStore=$path-to-truststore’ build &amp;lt;your-build-target&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Annex
    &lt;ol&gt;
      &lt;li&gt;more java option&lt;br /&gt;
  java app인 경우. http.proxyHost option으로는 부족할 때가 있다. (정확히 어떤 경우인지는 FFS이다.)&lt;br /&gt;
  이 때, 다음 option을 사용해 볼 수 있다.
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-Djava.net.useSystemProxies=true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;em&gt;JAVA_HOME&lt;/em&gt; of OSX
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sun, 14 Apr 2019 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/tensorflow/2019/04/14/bazel-behind-proxy.html</link>
        <guid isPermaLink="true">http://localhost:4000/tensorflow/2019/04/14/bazel-behind-proxy.html</guid>
        
        
        <category>tensorflow</category>
        
      </item>
    
      <item>
        <title>필사 방법 정리</title>
        <description>&lt;p&gt;글쓰기 공부를 위한 필사 방법을 정리.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;필사할 글은 본인이 직접 고른다.&lt;/li&gt;
  &lt;li&gt;먼저 쓱 읽는다.&lt;/li&gt;
  &lt;li&gt;몇 번 읽어서 전체 글이 무엇을 말하고자 하는지 파악한다.&lt;/li&gt;
  &lt;li&gt;필사를 하면서 단어, 문장 구조, 문장 접속 구조를 익힌다.
    &lt;ul&gt;
      &lt;li&gt;필사할 때는 가능한 문장 단위로 필사한다.&lt;/li&gt;
      &lt;li&gt;문장이 길면 가능한 가장 긴 의미 단위로 필사한다.&lt;/li&gt;
      &lt;li&gt;필사할 때는 자신이 문장을 작성한다는 생각으로 쓴다. 작성 후 원문과 비교해서 단어, 문장 구조등을 익힌다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;4번의 과정으로 문장 구조가 눈에 들어오면, 문단 구조, 문단 접속 구조로 넘어간다.&lt;/li&gt;
  &lt;li&gt;5번의 과정이 익숙해 지면, 글 전체 구조를 파악하는 단계로 넘어간다.&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Wed, 14 Feb 2018 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/writing/2018/02/14/my-transciption.html</link>
        <guid isPermaLink="true">http://localhost:4000/writing/2018/02/14/my-transciption.html</guid>
        
        
        <category>writing</category>
        
      </item>
    
      <item>
        <title>Tensorflow install</title>
        <description>&lt;h1 id=&quot;basic-package-install&quot;&gt;basic package install&lt;/h1&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo apt-get install python-numpy python-dev python-pip python-whee
$ sudo apt-get install python3-numpy python3-dev python3-pip python3-wheel
$ sudo apt-get install ipython swig libcupti-dev
$ sudo apt-get install git
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;install-bazel-custom-apt-repository&quot;&gt;install Bazel custom APT repository&lt;/h1&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo apt-get install openjdk-8-jdk

$ echo &quot;deb [arch=amd64] http://storage.googleapis.com/bazel-apt stable jdk1.8&quot; | sudo tee /etc/apt/sources.list.d/bazel.list
$ curl https://bazel.build/bazel-release.pub.gpg | sudo apt-key add -

$ sudo apt-get update &amp;amp;&amp;amp; sudo apt-get install bazel
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;install-depency-module&quot;&gt;install depency module&lt;/h1&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    # Python 2.7:
    $ pip install — upgrade pip
    $ pip install setuptools six numpy wheel jupyter
    
    # Python 3.x:
    $ pip3 install — upgrade pip
    $ pip3 install setuptools six numpy wheel jupyter    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;install-nvidia-package-on-host&quot;&gt;install NVIDIA package on host&lt;/h1&gt;

&lt;h2 id=&quot;driver&quot;&gt;driver&lt;/h2&gt;
&lt;p&gt;download and execute NVIDIA-Linux-x86_64-384.69.run&lt;/p&gt;

&lt;h2 id=&quot;install-cuda-toolkit&quot;&gt;install CUDA toolkit&lt;/h2&gt;
&lt;p&gt;https://developer.nvidia.com/cuda-downloads&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   $ sudo dpkg -i cuda-repo-ubuntu1604-8-0-local-ga2_8.0.61-1_amd64.deb
   $ sudo apt-get update
   $ sudo apt-get install cuda
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;cudnn-install&quot;&gt;cuDNN install&lt;/h2&gt;
&lt;p&gt;download from https://developer.nvidia.com/cudnn&lt;/p&gt;

&lt;p&gt;your CUDA directory path is preferred to as /usr/local/cuda&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ tar xvfz cudnn-9.0-linux-x64-v7.tgz

$ sudo cp cuda/include/cudnn.h /usr/local/cuda/include
$ sudo cp cuda/lib64/libcudnn* /usr/local/cuda/lib64
$ sudo chmod a+r /usr/local/cuda/include/cudnn.h /usr/local/cuda/lib64/libcudnn*

$ sudo dpkg -i libcudnn7_7.0.2.43-1+cuda9.0_amd64.deb
$ sudo dpkg -i libcudnn7-dev_7.0.2.43-1+cuda9.0_amd64.deb
$ sudo dpkg -i libcudnn7-doc_7.0.2.43-1+cuda9.0_amd64.deb```
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;docker-options-for-gpu-driver-interface&quot;&gt;Docker options for GPU driver interface&lt;/h1&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NVIDIA_SO=$(\ls -d /usr/lib/nvidia* | xargs -I{} echo '-v {}:{}')
CUDA_SO=$(\ls /usr/lib/x86_64-linux-gnu/libcuda* | xargs -I{} echo '-v {}:{}')
DEVICES=$(\ls /dev/nvidia* | xargs -I{} echo '--device {}:{}')

docker run -it --device /dev/mem:/dev/mem -v /lib/modules:/lib/modules --cap-add=ALL --privileged $CUDA_SO $NVIDIA_SO $DEVICES &amp;lt;docker image&amp;gt; /bin/bash
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;buildinstall-tensorflow&quot;&gt;build/install tensorflow&lt;/h1&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git clone https://github.com/tensorflow/tensorflow

$ bazel build -c opt --config=cuda //tensorflow/cc:tutorials_example_trainer
$ bazel-bin/tensorflow/cc/tutorials_example_trainer --use_gpu

$ bazel build --config=opt --config=cuda //tensorflow/tools/pip_package:build_pip_package
$ bazel-bin/tensorflow/tools/pip_package/build_pip_package /tmp/tensorflow_pkg

$ sudo pip install /tmp/tensorflow_pkg/tensorflow-1.3.0-py2-none-any.whl
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;install-validation&quot;&gt;Install validation&lt;/h1&gt;

&lt;h2 id=&quot;python-basic&quot;&gt;Python-basic&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import tensorflow as tf
hello = tf.constant('Hello, TensorFlow!')
sess = tf.Session()
print(sess.run(hello))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;python-gpu1&quot;&gt;Python-gpu1&lt;/h2&gt;

&lt;p&gt;To find out which devices your operations and tensors are assigned to, create the session with log_device_placement configuration option set to True.&lt;/p&gt;

&lt;h3 id=&quot;creates-a-graph&quot;&gt;Creates a graph.&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a = tf.constant([1.0, 2.0, 3.0, 4.0, 5.0, 6.0], shape=[2, 3], name='a')
b = tf.constant([1.0, 2.0, 3.0, 4.0, 5.0, 6.0], shape=[3, 2], name='b')
c = tf.matmul(a, b)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;creates-a-session-with-log_device_placement-set-to-true&quot;&gt;Creates a session with log_device_placement set to True.&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sess = tf.Session(config=tf.ConfigProto(log_device_placement=True))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;runs-the-op&quot;&gt;Runs the op.&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;print(sess.run(c))
You should see the following output:

Device mapping:
/job:localhost/replica:0/task:0/gpu:0 -&amp;gt; device: 0, name: Tesla K40c, pci bus
id: 0000:05:00.0
b: /job:localhost/replica:0/task:0/gpu:0
a: /job:localhost/replica:0/task:0/gpu:0
MatMul: /job:localhost/replica:0/task:0/gpu:0
[[ 22.  28.]
 [ 49.  64.]]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;python-gpu2&quot;&gt;Python-gpu2&lt;/h2&gt;
&lt;p&gt;If you would like a particular operation to run on a device of your choice instead of what’s automatically selected for you, you can use with tf.device to create a device context such that all the operations within that context will have the same device assignment.&lt;/p&gt;

&lt;h3 id=&quot;creates-a-graph-1&quot;&gt;Creates a graph.&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;with tf.device('/cpu:0'):
  a = tf.constant([1.0, 2.0, 3.0, 4.0, 5.0, 6.0], shape=[2, 3], name='a')
  b = tf.constant([1.0, 2.0, 3.0, 4.0, 5.0, 6.0], shape=[3, 2], name='b')
c = tf.matmul(a, b)
# Creates a session with log_device_placement set to True.
sess = tf.Session(config=tf.ConfigProto(log_device_placement=True))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;runs-the-op-1&quot;&gt;Runs the op.&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;print(sess.run(c))
You will see that now a and b are assigned to cpu:0. Since a device was not explicitly specified for the MatMul operation, the TensorFlow runtime will choose one based on the operation and available devices (gpu:0 in this example) and automatically copy tensors between devices if required.

Device mapping:
/job:localhost/replica:0/task:0/gpu:0 -&amp;gt; device: 0, name: Tesla K40c, pci bus
id: 0000:05:00.0
b: /job:localhost/replica:0/task:0/cpu:0
a: /job:localhost/replica:0/task:0/cpu:0
MatMul: /job:localhost/replica:0/task:0/gpu:0
[[ 22.  28.]
 [ 49.  64.]]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;jupyter-notebook&quot;&gt;Jupyter notebook&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;설정파일 만들기&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ jupyter notebook --generate-config
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;설정파일은 아래의 path에 만들어 진다.&lt;/p&gt;

&lt;p&gt;~/.jupyter/jupyter_notebook_config.py&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;generate password&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; from notebook.auth import passwd
 passwd()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;~/.jupyter/jupyter_notebook_config.py&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; c.NotebookApp.ip = ‘*’
 c.NotebookApp.password = u’sha1:....’
 c.NotebookApp.open_browser = False
 c.NotebookApp.port = 8888
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;issue&quot;&gt;issue&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;bazel build failure
[https://github.com/tensorflow/tensorflow/issues/12979]
github’s checksum is changed, bazel build will fail. 
For workaround, remove sha256 procedure from tensorflow/workspace.bzl&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sed -ri &quot;/^\W+sha256 = \&quot;[^\&quot;]+\&quot;\W+$/d&quot; tensorflow/workspace.bzl
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;ImportError:libcusolver.so.8.p0
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/cuda/lib64:/usr/lib/nvidia-&lt;version&gt;&lt;/version&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ImportError:nvidia-&lt;verstion&gt; libraries
need to link nvidia library path on host to docker by Volume interface&lt;/verstion&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;export NVIDIA_SO=$(\ls -d /usr/lib/nvidia*&lt;/td&gt;
      &lt;td&gt;xargs -I{} echo ‘-v {}:{}’)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;ImportError: No module named pywrap_tensorflow_internal
leave tensorflow source directory
python trys to import tensorflow from source directory not from install path&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;build for python3
at ./configure time, choose python3&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;dockerfile&quot;&gt;Dockerfile&lt;/h1&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;FROM ubuntu.user.base

RUN apt-get update &amp;amp;&amp;amp; apt-get -y -no-install-recommends install \
	python-pip python-dev python-numpy python-wheel swig\
	python3-pip python3-dev python3-numpy python3-wheel\		
	libcupti-dev git patch\
	openjdk-8-jdk

RUN echo &quot;deb [arch=amd64] http://storage.googleapis.com/bazel-apt stable jdk1.8&quot; | tee /etc/apt/sources.list.d/bazel.list
RUN curl https://bazel.build/bazel-release.pub.gpg | apt-key add -
RUN apt-get update &amp;amp;&amp;amp; apt-get install bazel

RUN pip install -upgrade pip
RUN pip install setuptools six numpy wheel jupyter

RUN pip3 install -upgrade pip
RUN pip3 install setuptools six numpy wheel jupyter
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Thu, 05 Oct 2017 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/deep-learning/2017/10/05/tensorflow-install.html</link>
        <guid isPermaLink="true">http://localhost:4000/deep-learning/2017/10/05/tensorflow-install.html</guid>
        
        
        <category>deep-learning</category>
        
      </item>
    
  </channel>
</rss>
