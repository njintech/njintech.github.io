<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>tesigners</title>
    <description></description>
    <link>http://tesigner.github.io/</link>
    <atom:link href="http://tesigner.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 06 Sep 2017 06:38:23 +0900</pubDate>
    <lastBuildDate>Wed, 06 Sep 2017 06:38:23 +0900</lastBuildDate>
    <generator>Jekyll v3.1.6</generator>
    
      <item>
        <title>Emacs configuration</title>
        <description>&lt;p&gt;이 포스팅은 내가 사용하는 Emacs의 기능들의 설치 및 설정 방법에 대한 기록이다.&lt;br /&gt;
현재 사용중인 Emacs의 버전은 24.5.1이며, mac/ubuntu에서 사용중이다.&lt;br /&gt;
따라서, mac과 ubuntu에 특화된 내용이 혼재할 수 있다.&lt;/p&gt;

&lt;h1 id=&quot;proxy&quot;&gt;proxy&lt;/h1&gt;

&lt;p&gt;방화벽 내부에서 MELPA를 사용하려면 proxy설정이 필요하다.&lt;br /&gt;
init.el에 다음의 proxy설정을 추가하면 된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(setq url-proxy-services
   &#39;((&quot;no_proxy&quot; . &quot;^\\(localhost\\|10.*\\)&quot;)
     (&quot;http&quot; . &quot;proxy.com:8080&quot;)
     (&quot;https&quot; . &quot;proxy.com:8080&quot;)))
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;no_proxy는 regex matching으로 표현된다.&lt;/p&gt;

&lt;h1 id=&quot;helm-install-and-configuration&quot;&gt;helm install and configuration&lt;/h1&gt;
&lt;p&gt;vim에서는 ctags, cscope조합을 사용했는데, code browser로 helm을 사용한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;mac&lt;/p&gt;

    &lt;p&gt;mac에서는 init.el의 command로 MELPA를 이용해 설치한다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(require &#39;setup-helm)
(require &#39;setup-helm-gtags))
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ubuntu&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;apt-get install elpa-helm
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 06 Sep 2017 00:00:00 +0900</pubDate>
        <link>http://tesigner.github.io/dev-common/2017/09/06/EmacsForMe.html</link>
        <guid isPermaLink="true">http://tesigner.github.io/dev-common/2017/09/06/EmacsForMe.html</guid>
        
        
        <category>dev-common</category>
        
      </item>
    
      <item>
        <title>Docker 사용에 대한 단상</title>
        <description>&lt;p&gt;서비/서비스 구성이 아닌, 개발환경으로 Docker를 사용해보려고 시도를 해봤다.
결론을 먼저 말하면, 그다지 매력적이지는 않다는 것이다. 물론 내 개인의 생각이다.
매력적이지 않다는 것은, 만들어진 이미지를 실행만 시키면, 어느 머신에서든 똑같은 환경으로 사용하기가 힘들다는 것이다. 물론, 개발환경으로써의 사용하는 경우를 말한다.&lt;/p&gt;

&lt;p&gt;처음 접한 것은 Tensorflow를 docker용 image 로 다운받았을 때였다. 그래서 자연스럽게 개발환경으로써 Docker를 받아들였다. 그러다가, 개발환경을 백업 및 일관성을 위한 팀내 공유를 위해 사용해보면 좋겠다라는 생각을 하고
실효성 테스트를 해봤다.&lt;/p&gt;

&lt;p&gt;문제가 되는 부분은 딱 하나였다. Volume을 사용하는 경우의  계정 콘트롤.&lt;/p&gt;

&lt;p&gt;Docker를 사용하다보면, Volume interface를 통해서 Host의 storage를 사용하게 된다.
그 경우는 대부분 data base와 패키지 혹은 소스파일들이다. 개발환경일 경우에는, 개발자의 소스파일들이 된다.&lt;/p&gt;

&lt;p&gt;문제는, Host와 Docker image의 계정정보(UID) 가 일치하지 않는다는데 있다.
게다가, Docker context에서 만드는 파일들은, Docker context의 계정 권한으로 만들어진다. Host에서 이 파일들은 Docker context user의 UID에 상응하는 Host상의 user 권한으로 인식된다.&lt;/p&gt;

&lt;p&gt;따라서, 올바르게 Docker를 사용하려면, 둘 사이의 계정 정보를 일치시키는 작업이 필요하다.&lt;/p&gt;

&lt;p&gt;서비스를 구성하는 경우에는, Docker image를 만들때, Host의 계정 상황에 맞춰서, 필요한 계정을 만들고, 해당 계정으로 서비스들을 설치하면 된다.
하지만, 개발환경의 경우 필요한 패키지를 수시로 설치, 업데이트 해야하고, 그때마다 이미지를 새로 만들고, 계정정보 매칭하고 해야하는 배포작업을 해야한다. 한마디로, 또 다른 일이 생기는 것이다.&lt;/p&gt;

&lt;p&gt;개발환경으로 Docker를 사용하면 좋은 경우는, 남의 서버에 기생하면서 특정 개발환경을 사용하려고 할때, 혹은, 검증 안된 개발환경을 새로 도입할때 테스트용으로 사용하는 경우에사용하는 것이 좋겠다는 것이 나의 결론이다.&lt;/p&gt;

&lt;p&gt;이상으로 2일동안의 도커 실효성 테스트 후, 도커에 대한 단상이었다.&lt;/p&gt;

</description>
        <pubDate>Wed, 16 Aug 2017 00:00:00 +0900</pubDate>
        <link>http://tesigner.github.io/essay/2017/08/16/EssayOnDockerUsage.html</link>
        <guid isPermaLink="true">http://tesigner.github.io/essay/2017/08/16/EssayOnDockerUsage.html</guid>
        
        
        <category>essay</category>
        
      </item>
    
      <item>
        <title>Docker ubuntu 16.04에서 Caffe 설치</title>
        <description>&lt;p&gt;1.package dependencies&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$sudo apt-get install libprotobuf-dev libleveldb-dev libsnappy-dev libopencv-dev libhdf5-serial-dev protobuf-compiler
$sudo apt-get install --no-install-recommends libboost-all-dev
$sudo apt-get install libgflags-dev libgoogle-glog-dev liblmdb-dev libatlas-base-dev
$sudo apt-get install cmake
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2.caffe 소스 받기&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$git clone https://github.com/BVLC/caffe.git
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;3.compile&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$mkdir build
$cd build
$cmake ..
$make all -j8
$make install
$make runtest
$make pycaffe
$make distribute
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;env
export PYTHONPATH=$PYTHONPATH:/path/to/caffe-master/python&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;5.commit docker image&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;변경된 docker container를 새로운 docker image에 commit한다.

$docker commit &amp;lt;container ID&amp;gt; &amp;lt;NewImageName&amp;gt;

이때, NewImageName은 현재 실행중인 container의 image여도 된다.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Mon, 07 Aug 2017 00:00:00 +0900</pubDate>
        <link>http://tesigner.github.io/deep-learning/2017/08/07/Caffe-Install.html</link>
        <guid isPermaLink="true">http://tesigner.github.io/deep-learning/2017/08/07/Caffe-Install.html</guid>
        
        
        <category>deep-learning</category>
        
      </item>
    
  </channel>
</rss>
